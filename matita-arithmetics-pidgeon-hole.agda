open import Agda.Primitive
open import matita-arithmetics-bounded-quantifiers
open import matita-basics-bool
open import matita-basics-logic
open import matita-basics-lists-list
open import matita-arithmetics-nat
decidable-mem-nat : (n : nat) -> (l : list lzero nat) -> decidable lzero (mem lzero nat n l)
decidable-mem-nat = λ (n : nat) -> λ (l : list lzero nat) -> list-ind lzero lzero nat (λ (X-x-716 : list lzero nat) -> decidable lzero (mem lzero nat n X-x-716)) (or-intror lzero lzero (mem lzero nat n (nil lzero nat)) (Not lzero (mem lzero nat n (nil lzero nat))) (nmk lzero (mem lzero nat n (nil lzero nat)) (False-ind lzero lzero (λ (X-x-66 : False lzero) -> False lzero)))) (λ (a : nat) -> λ (tl : list lzero nat) -> λ (Htl : decidable lzero (mem lzero nat n tl)) -> decidable-or lzero lzero (eq lzero nat n a) (mem lzero nat n tl) (decidable-eq-nat n a) Htl) l

length-unique-le : (n : nat) -> (l : list lzero nat) -> (X-- : unique lzero nat l) -> (X--1 : (x : nat) -> (X--1 : mem lzero nat x l) -> lt x n) -> le (length lzero nat l) n
length-unique-le = λ (n : nat) -> nat-ind lzero (λ (X-x-365 : nat) -> (l : list lzero nat) -> (X-- : unique lzero nat l) -> (X--1 : (x : nat) -> (X--1 : mem lzero nat x l) -> lt x X-x-365) -> le (length lzero nat l) X-x-365) (λ (X-clearme : list lzero nat) -> match-list lzero nat lzero (λ (X-- : list lzero nat) -> (X--1 : unique lzero nat X--) -> (X--2 : (x : nat) -> (X--2 : mem lzero nat x X--) -> lt x O) -> le (length lzero nat X--) O) (λ (auto : unique lzero nat (nil lzero nat)) -> λ (auto' : (x : nat) -> (X-- : mem lzero nat x (nil lzero nat)) -> lt x O) -> le-n (length lzero nat (nil lzero nat))) (λ (a : nat) -> λ (tl : list lzero nat) -> λ (X-- : unique lzero nat (cons lzero nat a tl)) -> λ (H : (x : nat) -> (X--1 : mem lzero nat x (cons lzero nat a tl)) -> lt x O) -> False-ind lzero lzero (λ (X-x-66 : False lzero) -> le (length lzero nat (cons lzero nat a tl)) O) (absurd lzero (lt a O) (H a (or-introl lzero lzero (eq lzero nat a a) (mem lzero nat a tl) (refl lzero nat a))) (le-to-not-lt O a (le-O-n a)))) X-clearme) (λ (m : nat) -> λ (Hind : (l : list lzero nat) -> (X-- : unique lzero nat l) -> (X--1 : (x : nat) -> (X--1 : mem lzero nat x l) -> lt x m) -> le (length lzero nat l) m) -> λ (l : list lzero nat) -> λ (Huni : unique lzero nat l) -> λ (Hmem : (x : nat) -> (X-- : mem lzero nat x l) -> lt x (S m)) -> eq-ind lzero lzero nat (plus (length lzero nat (filter' lzero nat (eqb m) l)) (length lzero nat (filter' lzero nat (λ (x : nat) -> notb (eqb m x)) l))) (λ (x-1 : nat) -> λ (X-x-2 : eq lzero nat (plus (length lzero nat (filter' lzero nat (eqb m) l)) (length lzero nat (filter' lzero nat (λ (x : nat) -> notb (eqb m x)) l))) x-1) -> le x-1 (S m)) (transitive-le (plus (length lzero nat (filter' lzero nat (eqb m) l)) (length lzero nat (filter' lzero nat (λ (x : nat) -> notb (eqb m x)) l))) (plus (S O) (length lzero nat (filter' lzero nat (λ (x : nat) -> notb (eqb m x)) l))) (S m) (le-plus (length lzero nat (filter' lzero nat (eqb m) l)) (S O) (length lzero nat (filter' lzero nat (λ (x : nat) -> notb (eqb m x)) l)) (length lzero nat (filter' lzero nat (λ (x : nat) -> notb (eqb m x)) l)) (length-filter-eqb m l Huni) (le-n (length lzero nat (filter' lzero nat (λ (x : nat) -> notb (eqb m x)) l)))) (le-S-S (plus O (length lzero nat (filter' lzero nat (λ (x : nat) -> notb (eqb m x)) l))) m (Hind (filter' lzero nat (λ (x : nat) -> notb (eqb m x)) l) (unique-filter lzero nat l (λ (x : nat) -> notb (eqb m x)) Huni) (λ (x : nat) -> λ (memx : mem lzero nat x (filter' lzero nat (λ (x0 : nat) -> notb (eqb m x0)) l)) -> match-Or lzero lzero (lt x m) (eq lzero nat x m) lzero (λ (X-- : Or lzero lzero (lt x m) (eq lzero nat x m)) -> lt x m) (λ (auto : lt x m) -> auto) (λ (eqxm : eq lzero nat x m) -> False-ind lzero lzero (λ (X-x-66 : False lzero) -> lt x m) (absurd lzero (eq lzero nat x m) eqxm (sym-not-eq lzero nat m x (eqb-false-to-not-eq m x (injective-notb (eqb m x) false (mem-filter-true lzero nat (λ (x0 : nat) -> notb (eqb m x0)) x l memx)))))) (le-to-or-lt-eq x m (le-S-S-to-le x m (Hmem x (mem-filter lzero nat (λ (x0 : nat) -> notb (eqb m x0)) x l memx)))))))) (length lzero nat l) (filter-length2 lzero nat (eqb m) l)) n

eq-length-to-mem : (n : nat) -> (l : list lzero nat) -> (X-- : eq lzero nat (length lzero nat l) (S n)) -> (X--1 : unique lzero nat l) -> (X--2 : (x : nat) -> (X--2 : mem lzero nat x l) -> le x n) -> mem lzero nat n l
eq-length-to-mem = λ (n : nat) -> λ (l : list lzero nat) -> λ (H1 : eq lzero nat (length lzero nat l) (S n)) -> λ (H2 : unique lzero nat l) -> λ (H3 : (x : nat) -> (X-- : mem lzero nat x l) -> le x n) -> match-Or lzero lzero (mem lzero nat n l) (Not lzero (mem lzero nat n l)) lzero (λ (X-- : Or lzero lzero (mem lzero nat n l) (Not lzero (mem lzero nat n l))) -> mem lzero nat n l) (λ (auto : mem lzero nat n l) -> auto) (λ (H4 : Not lzero (mem lzero nat n l)) -> False-ind lzero lzero (λ (X-x-66 : False lzero) -> mem lzero nat n l) (absurd lzero (gt (length lzero nat l) n) (eq-ind-r lzero lzero nat (S n) (λ (x : nat) -> λ (X-- : eq lzero nat x (S n)) -> gt x n) (le-n (S n)) (length lzero nat l) H1) (le-to-not-lt (length lzero nat l) n (length-unique-le n l H2 (λ (x : nat) -> λ (memx : mem lzero nat x l) -> match-Or lzero lzero (lt x n) (eq lzero nat x n) lzero (λ (X-- : Or lzero lzero (lt x n) (eq lzero nat x n)) -> lt x n) (λ (auto : lt x n) -> auto) (λ (Heq : eq lzero nat x n) -> not-le-to-lt n x (not-to-not lzero (le n x) (mem lzero nat n l) (λ (X-- : le n x) -> eq-ind lzero lzero nat x (λ (x-1 : nat) -> λ (X-x-2 : eq lzero nat x x-1) -> mem lzero nat x-1 l) memx n Heq) H4)) (le-to-or-lt-eq x n (H3 x memx))))))) (decidable-mem-nat n l)

eq-length-to-mem-all : (n : nat) -> (l : list lzero nat) -> (X-- : eq lzero nat (length lzero nat l) n) -> (X--1 : unique lzero nat l) -> (X--2 : (x : nat) -> (X--2 : mem lzero nat x l) -> lt x n) -> (i : nat) -> (X--3 : lt i n) -> mem lzero nat i l
eq-length-to-mem-all = λ (n : nat) -> nat-ind lzero (λ (X-x-365 : nat) -> (l : list lzero nat) -> (X-- : eq lzero nat (length lzero nat l) X-x-365) -> (X--1 : unique lzero nat l) -> (X--2 : (x : nat) -> (X--2 : mem lzero nat x l) -> lt x X-x-365) -> (i : nat) -> (X--3 : lt i X-x-365) -> mem lzero nat i l) (λ (l : list lzero nat) -> λ (X-- : eq lzero nat (length lzero nat l) O) -> λ (X-0 : unique lzero nat l) -> λ (X-1 : (x : nat) -> (X--1 : mem lzero nat x l) -> lt x O) -> λ (i : nat) -> λ (lti0 : lt i O) -> False-ind lzero lzero (λ (X-x-66 : False lzero) -> mem lzero nat i l) (absurd lzero (lt i O) lti0 (not-le-Sn-O i))) (λ (m : nat) -> λ (Hind : (l : list lzero nat) -> (X-- : eq lzero nat (length lzero nat l) m) -> (X--1 : unique lzero nat l) -> (X--2 : (x : nat) -> (X--2 : mem lzero nat x l) -> lt x m) -> (i : nat) -> (X--3 : lt i m) -> mem lzero nat i l) -> λ (l : list lzero nat) -> λ (H : eq lzero nat (length lzero nat l) (S m)) -> λ (H1 : unique lzero nat l) -> λ (H2 : (x : nat) -> (X-- : mem lzero nat x l) -> lt x (S m)) -> λ (i : nat) -> λ (lei : lt i (S m)) -> match-Or lzero lzero (lt (S i) (S m)) (eq lzero nat (S i) (S m)) lzero (λ (X-- : Or lzero lzero (lt (S i) (S m)) (eq lzero nat (S i) (S m))) -> mem lzero nat i l) (λ (leim : lt (S i) (S m)) -> mem-filter lzero nat (λ (i0 : nat) -> notb (eqb m i0)) i l (match-Or lzero lzero (And lzero lzero (mem lzero nat m l) (eq lzero (list lzero nat) (filter' lzero nat (eqb m) l) (cons lzero nat m (nil lzero nat)))) (And lzero lzero (Not lzero (mem lzero nat m l)) (eq lzero (list lzero nat) (filter' lzero nat (eqb m) l) (nil lzero nat))) lzero (λ (X-- : Or lzero lzero (And lzero lzero (mem lzero nat m l) (eq lzero (list lzero nat) (filter' lzero nat (eqb m) l) (cons lzero nat m (nil lzero nat)))) (And lzero lzero (Not lzero (mem lzero nat m l)) (eq lzero (list lzero nat) (filter' lzero nat (eqb m) l) (nil lzero nat)))) -> mem lzero nat i (filter' lzero nat (λ (i0 : nat) -> notb (eqb m i0)) l)) (λ (X-clearme : And lzero lzero (mem lzero nat m l) (eq lzero (list lzero nat) (filter' lzero nat (eqb m) l) (cons lzero nat m (nil lzero nat)))) -> match-And lzero lzero (mem lzero nat m l) (eq lzero (list lzero nat) (filter' lzero nat (eqb m) l) (cons lzero nat m (nil lzero nat))) lzero (λ (X-- : And lzero lzero (mem lzero nat m l) (eq lzero (list lzero nat) (filter' lzero nat (eqb m) l) (cons lzero nat m (nil lzero nat)))) -> mem lzero nat i (filter' lzero nat (λ (i0 : nat) -> notb (eqb m i0)) l)) (λ (memm : mem lzero nat m l) -> λ (Hfilter : eq lzero (list lzero nat) (filter' lzero nat (eqb m) l) (cons lzero nat m (nil lzero nat))) -> Hind (filter' lzero nat (λ (i0 : nat) -> notb (eqb m i0)) l) (injective-S (length lzero nat (filter' lzero nat (λ (i0 : nat) -> notb (eqb m i0)) l)) m (eq-ind lzero lzero nat (length lzero nat l) (λ (x-1 : nat) -> λ (X-x-2 : eq lzero nat (length lzero nat l) x-1) -> eq lzero nat (S (length lzero nat (filter' lzero nat (λ (i0 : nat) -> notb (eqb m i0)) l))) x-1) (eq-ind lzero lzero nat (plus (length lzero nat (filter' lzero nat (eqb m) l)) (length lzero nat (filter' lzero nat (λ (x : nat) -> notb (eqb m x)) l))) (λ (x-1 : nat) -> λ (X-x-2 : eq lzero nat (plus (length lzero nat (filter' lzero nat (eqb m) l)) (length lzero nat (filter' lzero nat (λ (x : nat) -> notb (eqb m x)) l))) x-1) -> eq lzero nat (S (length lzero nat (filter' lzero nat (λ (i0 : nat) -> notb (eqb m i0)) l))) x-1) (eq-ind-r lzero lzero (list lzero nat) (cons lzero nat m (nil lzero nat)) (λ (x : list lzero nat) -> λ (X-- : eq lzero (list lzero nat) x (cons lzero nat m (nil lzero nat))) -> eq lzero nat (S (length lzero nat (filter' lzero nat (λ (i0 : nat) -> notb (eqb m i0)) l))) (plus (length lzero nat x) (length lzero nat (filter' lzero nat (λ (x0 : nat) -> notb (eqb m x0)) l)))) (refl lzero nat (S (length lzero nat (filter' lzero nat (λ (i0 : nat) -> notb (eqb m i0)) l)))) (filter' lzero nat (eqb m) l) Hfilter) (length lzero nat l) (filter-length2 lzero nat (eqb m) l)) (S m) H)) (unique-filter lzero nat l (λ (i0 : nat) -> notb (eqb m i0)) H1) (λ (x : nat) -> λ (memx : mem lzero nat x (filter' lzero nat (λ (i0 : nat) -> notb (eqb m i0)) l)) -> match-Or lzero lzero (lt (S x) (S m)) (eq lzero nat (S x) (S m)) lzero (λ (X-- : Or lzero lzero (lt (S x) (S m)) (eq lzero nat (S x) (S m))) -> lt x m) (λ (H3 : lt (S x) (S m)) -> le-S-S-to-le (S x) m H3) (λ (H3 : eq lzero nat (S x) (S m)) -> False-ind lzero lzero (λ (X-x-66 : False lzero) -> lt x m) (absurd lzero (eq lzero nat m x) (injective-S m x (rewrite-l lzero lzero nat (length lzero nat l) (λ (X-- : nat) -> eq lzero nat X-- (S x)) (rewrite-r lzero lzero nat (length lzero nat l) (λ (X-- : nat) -> eq lzero nat (length lzero nat l) X--) (refl lzero nat (length lzero nat l)) (S x) (rewrite-r lzero lzero nat (S m) (λ (X-- : nat) -> eq lzero nat (S x) X--) H3 (length lzero nat l) H)) (S m) H)) (eqb-false-to-not-eq m x (injective-notb (eqb m x) false (eq-ind-r lzero lzero bool true (λ (x0 : bool) -> λ (X-- : eq lzero bool x0 true) -> eq lzero bool x0 (notb false)) (refl lzero bool true) (notb (eqb m x)) (mem-filter-true lzero nat (λ (i0 : nat) -> notb (eqb m i0)) x l memx)))))) (le-to-or-lt-eq (S x) (S m) (H2 x (mem-filter lzero nat (λ (i0 : nat) -> notb (eqb m i0)) x l memx)))) i (le-S-S-to-le (S i) m leim)) X-clearme) (λ (X-clearme : And lzero lzero (Not lzero (mem lzero nat m l)) (eq lzero (list lzero nat) (filter' lzero nat (eqb m) l) (nil lzero nat))) -> match-And lzero lzero (Not lzero (mem lzero nat m l)) (eq lzero (list lzero nat) (filter' lzero nat (eqb m) l) (nil lzero nat)) lzero (λ (X-- : And lzero lzero (Not lzero (mem lzero nat m l)) (eq lzero (list lzero nat) (filter' lzero nat (eqb m) l) (nil lzero nat))) -> mem lzero nat i (filter' lzero nat (λ (i0 : nat) -> notb (eqb m i0)) l)) (λ (H0 : Not lzero (mem lzero nat m l)) -> False-ind lzero lzero (λ (X-x-66 : False lzero) -> (X-- : eq lzero (list lzero nat) (filter' lzero nat (eqb m) l) (nil lzero nat)) -> mem lzero nat i (filter' lzero nat (λ (i0 : nat) -> notb (eqb m i0)) l)) (absurd lzero (mem lzero nat m l) (eq-length-to-mem m l (rewrite-l lzero lzero nat (length lzero nat l) (λ (X-- : nat) -> eq lzero nat (length lzero nat l) X--) (refl lzero nat (length lzero nat l)) (S m) H) H1 (λ (x : nat) -> λ (memx : mem lzero nat x l) -> le-S-S-to-le x m (H2 x memx))) H0)) X-clearme) (filter-eqb m l H1))) (λ (eqi : eq lzero nat (S i) (S m)) -> eq-length-to-mem i l (eq-ind-r lzero lzero nat (S m) (λ (x : nat) -> λ (X-- : eq lzero nat x (S m)) -> eq lzero nat (length lzero nat l) x) H (S i) eqi) (eq-ind-r lzero lzero nat (S m) (λ (x : nat) -> λ (X-- : eq lzero nat x (S m)) -> unique lzero nat l) H1 (S i) eqi) (eq-ind-r lzero lzero nat (S m) (λ (x : nat) -> λ (X-- : eq lzero nat x (S m)) -> (x0 : nat) -> (X--1 : mem lzero nat x0 l) -> le x0 i) (λ (x : nat) -> λ (Hx : mem lzero nat x l) -> le-S-S-to-le x i (eq-ind-r lzero lzero nat (S m) (λ (x0 : nat) -> λ (X-- : eq lzero nat x0 (S m)) -> le (S x) x0) (H2 x Hx) (S i) eqi)) (S i) eqi)) (le-to-or-lt-eq (S i) (S m) lei)) n

lt-length-to-not-mem : (n : nat) -> (l : list lzero nat) -> (X-- : unique lzero nat l) -> (X--1 : (x : nat) -> (X--1 : mem lzero nat x l) -> lt x n) -> (X--2 : lt (length lzero nat l) n) -> ex lzero lzero nat (λ (i : nat) -> And lzero lzero (lt i n) (Not lzero (mem lzero nat i l)))
lt-length-to-not-mem = λ (n : nat) -> nat-ind lzero (λ (X-x-365 : nat) -> (l : list lzero nat) -> (X-- : unique lzero nat l) -> (X--1 : (x : nat) -> (X--1 : mem lzero nat x l) -> lt x X-x-365) -> (X--2 : lt (length lzero nat l) X-x-365) -> ex lzero lzero nat (λ (i : nat) -> And lzero lzero (lt i X-x-365) (Not lzero (mem lzero nat i l)))) (λ (l : list lzero nat) -> λ (X-- : unique lzero nat l) -> λ (X-0 : (x : nat) -> (X--1 : mem lzero nat x l) -> lt x O) -> λ (H : lt (length lzero nat l) O) -> False-ind lzero lzero (λ (X-x-66 : False lzero) -> ex lzero lzero nat (λ (i : nat) -> And lzero lzero (lt i O) (Not lzero (mem lzero nat i l)))) (absurd lzero (le (S (length lzero nat l)) O) H (not-le-Sn-O (length lzero nat l)))) (λ (m : nat) -> λ (Hind : (l : list lzero nat) -> (X-- : unique lzero nat l) -> (X--1 : (x : nat) -> (X--1 : mem lzero nat x l) -> lt x m) -> (X--2 : lt (length lzero nat l) m) -> ex lzero lzero nat (λ (i : nat) -> And lzero lzero (lt i m) (Not lzero (mem lzero nat i l)))) -> λ (l : list lzero nat) -> λ (Huni : unique lzero nat l) -> λ (Hmem : (x : nat) -> (X-- : mem lzero nat x l) -> lt x (S m)) -> λ (Hlen : lt (length lzero nat l) (S m)) -> match-Or lzero lzero (And lzero lzero (mem lzero nat m l) (eq lzero (list lzero nat) (filter' lzero nat (eqb m) l) (cons lzero nat m (nil lzero nat)))) (And lzero lzero (Not lzero (mem lzero nat m l)) (eq lzero (list lzero nat) (filter' lzero nat (eqb m) l) (nil lzero nat))) lzero (λ (X-- : Or lzero lzero (And lzero lzero (mem lzero nat m l) (eq lzero (list lzero nat) (filter' lzero nat (eqb m) l) (cons lzero nat m (nil lzero nat)))) (And lzero lzero (Not lzero (mem lzero nat m l)) (eq lzero (list lzero nat) (filter' lzero nat (eqb m) l) (nil lzero nat)))) -> ex lzero lzero nat (λ (i : nat) -> And lzero lzero (lt i (S m)) (Not lzero (mem lzero nat i l)))) (λ (X-clearme : And lzero lzero (mem lzero nat m l) (eq lzero (list lzero nat) (filter' lzero nat (eqb m) l) (cons lzero nat m (nil lzero nat)))) -> match-And lzero lzero (mem lzero nat m l) (eq lzero (list lzero nat) (filter' lzero nat (eqb m) l) (cons lzero nat m (nil lzero nat))) lzero (λ (X-- : And lzero lzero (mem lzero nat m l) (eq lzero (list lzero nat) (filter' lzero nat (eqb m) l) (cons lzero nat m (nil lzero nat)))) -> ex lzero lzero nat (λ (i : nat) -> And lzero lzero (lt i (S m)) (Not lzero (mem lzero nat i l)))) (λ (memm : mem lzero nat m l) -> λ (Hfilter : eq lzero (list lzero nat) (filter' lzero nat (eqb m) l) (cons lzero nat m (nil lzero nat))) -> match-ex lzero lzero nat (λ (i : nat) -> And lzero lzero (lt i m) (Not lzero (mem lzero nat i (filter' lzero nat (λ (x : nat) -> notb (eqb m x)) l)))) lzero (λ (X-- : ex lzero lzero nat (λ (i : nat) -> And lzero lzero (lt i m) (Not lzero (mem lzero nat i (filter' lzero nat (λ (x : nat) -> notb (eqb m x)) l))))) -> ex lzero lzero nat (λ (i : nat) -> And lzero lzero (lt i (S m)) (Not lzero (mem lzero nat i l)))) (λ (i : nat) -> λ (X-clearme0 : And lzero lzero (lt i m) (Not lzero (mem lzero nat i (filter' lzero nat (λ (x0 : nat) -> notb (eqb m x0)) l)))) -> match-And lzero lzero (lt i m) (Not lzero (mem lzero nat i (filter' lzero nat (λ (x0 : nat) -> notb (eqb m x0)) l))) lzero (λ (X-- : And lzero lzero (lt i m) (Not lzero (mem lzero nat i (filter' lzero nat (λ (x0 : nat) -> notb (eqb m x0)) l)))) -> ex lzero lzero nat (λ (i0 : nat) -> And lzero lzero (lt i0 (S m)) (Not lzero (mem lzero nat i0 l)))) (λ (ltim : lt i m) -> λ (memi : Not lzero (mem lzero nat i (filter' lzero nat (λ (x0 : nat) -> notb (eqb m x0)) l))) -> ex-intro lzero lzero nat (λ (i0 : nat) -> And lzero lzero (lt i0 (S m)) (Not lzero (mem lzero nat i0 l))) i (conj lzero lzero (lt i (S m)) (Not lzero (mem lzero nat i l)) (le-S (S i) m ltim) (not-to-not lzero (mem lzero nat i l) (mem lzero nat i (filter' lzero nat (λ (x0 : nat) -> notb (eqb m x0)) l)) (mem-filter-l lzero nat (λ (x0 : nat) -> notb (eqb m x0)) i l (injective-notb (notb (eqb m i)) true (eq-ind-r lzero lzero bool (eqb m i) (λ (x : bool) -> λ (X-- : eq lzero bool x (eqb m i)) -> eq lzero bool x (notb true)) (not-eq-to-eqb-false m i (sym-not-eq lzero nat i m (lt-to-not-eq i m ltim))) (notb (notb (eqb m i))) (notb-notb (eqb m i))))) memi))) X-clearme0) (Hind (filter' lzero nat (λ (x : nat) -> notb (eqb m x)) l) (unique-filter lzero nat l (λ (x : nat) -> notb (eqb m x)) Huni) (λ (x : nat) -> λ (memx : mem lzero nat x (filter' lzero nat (λ (x0 : nat) -> notb (eqb m x0)) l)) -> match-Or lzero lzero (lt (S x) (S m)) (eq lzero nat (S x) (S m)) lzero (λ (X-- : Or lzero lzero (lt (S x) (S m)) (eq lzero nat (S x) (S m))) -> lt x m) (λ (H : lt (S x) (S m)) -> le-S-S-to-le (S x) m H) (λ (H : eq lzero nat (S x) (S m)) -> False-ind lzero lzero (λ (X-x-66 : False lzero) -> lt x m) (absurd lzero (eq lzero nat m x) (injective-S m x (rewrite-r lzero lzero nat (S m) (λ (X-- : nat) -> eq lzero nat (S m) X--) (refl lzero nat (S m)) (S x) H)) (eqb-false-to-not-eq m x (injective-notb (eqb m x) false (eq-ind-r lzero lzero bool true (λ (x0 : bool) -> λ (X-- : eq lzero bool x0 true) -> eq lzero bool x0 (notb false)) (refl lzero bool true) (notb (eqb m x)) (mem-filter-true lzero nat (λ (x0 : nat) -> notb (eqb m x0)) x l memx)))))) (le-to-or-lt-eq (S x) (S m) (Hmem x (mem-filter lzero nat (λ (x0 : nat) -> notb (eqb m x0)) x l memx)))) (eq-ind lzero lzero nat (plus (length lzero nat (filter' lzero nat (eqb m) l)) (length lzero nat (filter' lzero nat (λ (x : nat) -> notb (eqb m x)) l))) (λ (x-1 : nat) -> λ (X-x-2 : eq lzero nat (plus (length lzero nat (filter' lzero nat (eqb m) l)) (length lzero nat (filter' lzero nat (λ (x : nat) -> notb (eqb m x)) l))) x-1) -> (X-- : lt x-1 (S m)) -> lt (length lzero nat (filter' lzero nat (λ (x : nat) -> notb (eqb m x)) l)) m) (eq-ind-r lzero lzero (list lzero nat) (cons lzero nat m (nil lzero nat)) (λ (x : list lzero nat) -> λ (X-- : eq lzero (list lzero nat) x (cons lzero nat m (nil lzero nat))) -> (X--1 : lt (plus (length lzero nat x) (length lzero nat (filter' lzero nat (λ (x0 : nat) -> notb (eqb m x0)) l))) (S m)) -> lt (length lzero nat (filter' lzero nat (λ (x0 : nat) -> notb (eqb m x0)) l)) m) (λ (H : lt (plus (length lzero nat (cons lzero nat m (nil lzero nat))) (length lzero nat (filter' lzero nat (λ (x : nat) -> notb (eqb m x)) l))) (S m)) -> le-S-S-to-le (S (length lzero nat (filter' lzero nat (λ (x : nat) -> notb (eqb m x)) l))) m H) (filter' lzero nat (eqb m) l) Hfilter) (length lzero nat l) (filter-length2 lzero nat (eqb m) l) Hlen))) X-clearme) (λ (X-clearme : And lzero lzero (Not lzero (mem lzero nat m l)) (eq lzero (list lzero nat) (filter' lzero nat (eqb m) l) (nil lzero nat))) -> match-And lzero lzero (Not lzero (mem lzero nat m l)) (eq lzero (list lzero nat) (filter' lzero nat (eqb m) l) (nil lzero nat)) lzero (λ (X-- : And lzero lzero (Not lzero (mem lzero nat m l)) (eq lzero (list lzero nat) (filter' lzero nat (eqb m) l) (nil lzero nat))) -> ex lzero lzero nat (λ (i : nat) -> And lzero lzero (lt i (S m)) (Not lzero (mem lzero nat i l)))) (λ (H : Not lzero (mem lzero nat m l)) -> λ (X-- : eq lzero (list lzero nat) (filter' lzero nat (eqb m) l) (nil lzero nat)) -> ex-intro lzero lzero nat (λ (i : nat) -> And lzero lzero (lt i (S m)) (Not lzero (mem lzero nat i l))) m (conj lzero lzero (lt m (S m)) (Not lzero (mem lzero nat m l)) (eq-coerc lzero (lt m (plus (plus m O) (S O))) (lt m (S m)) (lt-plus-Sn-r m O O) (rewrite-l lzero (lsuc lzero) nat m (λ (X--1 : nat) -> eq (lsuc lzero) (Set (lzero)) (lt m (plus X--1 (S O))) (lt m (S m))) (rewrite-l lzero (lsuc lzero) nat (S m) (λ (X--1 : nat) -> eq (lsuc lzero) (Set (lzero)) (lt m X--1) (lt m (S m))) (refl (lsuc lzero) (Set (lzero)) (lt m (S m))) (plus m (S O)) (rewrite-r lzero lzero nat (plus m O) (λ (X--1 : nat) -> eq lzero nat (S X--1) (plus m (S O))) (plus-n-Sm m O) m (plus-n-O m))) (plus m O) (plus-n-O m))) H)) X-clearme) (filter-eqb m l Huni)) n

