open import Agda.Primitive
open import matita-basics-logic
open import matita-arithmetics-nat
decidable-not : (l37 : Level) -> (P : Set l37) -> (X-- : decidable l37 P) -> decidable l37 (Not l37 P)
decidable-not = λ (l37 : Level) -> λ (P : Set l37) -> λ (X-clearme : decidable l37 P) -> match-Or l37 l37 P (Not l37 P) l37 (λ (X-- : Or l37 l37 P (Not l37 P)) -> decidable l37 (Not l37 P)) (λ (H : P) -> or-intror l37 l37 (Not l37 P) (Not l37 (Not l37 P)) (nmk l37 (Not l37 P) (λ (X-clearme0 : Not l37 P) -> match-Not l37 P l37 (λ (X-- : Not l37 P) -> False l37) (λ (auto : (X-- : P) -> False l37) -> auto H) X-clearme0))) (λ (H : Not l37 P) -> or-introl l37 l37 (Not l37 P) (Not l37 (Not l37 P)) H) X-clearme

decidable-or : (ll1 ll0 : Level) -> (P : Set (lzero ⊔ (ll1 ⊔ ll0))) -> (Q : Set (lzero ⊔ (ll1 ⊔ ll0))) -> (X-- : decidable (ll1 ⊔ ll0) P) -> (X--1 : decidable (ll1 ⊔ ll0) Q) -> decidable (ll1 ⊔ ll0) (Or (ll1 ⊔ ll0) (ll1 ⊔ ll0) P Q)
decidable-or = λ (ll1 ll0 : Level) -> λ (P : Set (lzero ⊔ (ll1 ⊔ ll0))) -> λ (Q : Set (lzero ⊔ (ll1 ⊔ ll0))) -> λ (X-clearme : decidable (ll1 ⊔ ll0) P) -> match-Or (ll1 ⊔ ll0) (ll1 ⊔ ll0) P (Not (ll1 ⊔ ll0) P) (ll1 ⊔ ll0) (λ (X-- : Or (ll1 ⊔ ll0) (ll1 ⊔ ll0) P (Not (ll1 ⊔ ll0) P)) -> (X--1 : decidable (ll1 ⊔ ll0) Q) -> decidable (ll1 ⊔ ll0) (Or (ll1 ⊔ ll0) (ll1 ⊔ ll0) P Q)) (λ (HP : P) -> λ (X-- : decidable (ll1 ⊔ ll0) Q) -> or-introl (ll1 ⊔ ll0) (ll1 ⊔ ll0) (Or (ll1 ⊔ ll0) (ll1 ⊔ ll0) P Q) (Not (ll1 ⊔ ll0) (Or (ll1 ⊔ ll0) (ll1 ⊔ ll0) P Q)) (or-introl (ll1 ⊔ ll0) (ll1 ⊔ ll0) P Q HP)) (λ (HP : Not (ll1 ⊔ ll0) P) -> λ (X-clearme0 : decidable (ll1 ⊔ ll0) Q) -> match-Or (ll1 ⊔ ll0) (ll1 ⊔ ll0) Q (Not (ll1 ⊔ ll0) Q) (ll1 ⊔ ll0) (λ (X-- : Or (ll1 ⊔ ll0) (ll1 ⊔ ll0) Q (Not (ll1 ⊔ ll0) Q)) -> decidable (ll1 ⊔ ll0) (Or (ll1 ⊔ ll0) (ll1 ⊔ ll0) P Q)) (λ (HQ : Q) -> or-introl (ll1 ⊔ ll0) (ll1 ⊔ ll0) (Or (ll1 ⊔ ll0) (ll1 ⊔ ll0) P Q) (Not (ll1 ⊔ ll0) (Or (ll1 ⊔ ll0) (ll1 ⊔ ll0) P Q)) (or-intror (ll1 ⊔ ll0) (ll1 ⊔ ll0) P Q HQ)) (λ (HQ : Not (ll1 ⊔ ll0) Q) -> or-intror (ll1 ⊔ ll0) (ll1 ⊔ ll0) (Or (ll1 ⊔ ll0) (ll1 ⊔ ll0) P Q) (Not (ll1 ⊔ ll0) (Or (ll1 ⊔ ll0) (ll1 ⊔ ll0) P Q)) (nmk (ll1 ⊔ ll0) (Or (ll1 ⊔ ll0) (ll1 ⊔ ll0) P Q) (λ (X-clearme1 : Or (ll1 ⊔ ll0) (ll1 ⊔ ll0) P Q) -> match-Or (ll1 ⊔ ll0) (ll1 ⊔ ll0) P Q (ll1 ⊔ ll0) (λ (X-- : Or (ll1 ⊔ ll0) (ll1 ⊔ ll0) P Q) -> False (ll1 ⊔ ll0)) (λ (auto : P) -> absurd (ll1 ⊔ ll0) P auto HP) (λ (auto : Q) -> absurd (ll1 ⊔ ll0) Q auto HQ) X-clearme1))) X-clearme0) X-clearme

decidable-forall : (l220 : Level) -> (P : (X-- : nat) -> Set l220) -> (X-- : (i : nat) -> decidable l220 (P i)) -> (n : nat) -> decidable l220 ((i : nat) -> (X--1 : lt i n) -> P i)
decidable-forall = λ (l220 : Level) -> λ (P : (X-- : nat) -> Set l220) -> λ (Hdec : (i : nat) -> decidable l220 (P i)) -> λ (n : nat) -> nat-ind l220 (λ (X-x-365 : nat) -> decidable l220 ((i : nat) -> (X-- : lt i X-x-365) -> P i)) (or-introl l220 l220 ((i : nat) -> (X-- : lt i O) -> P i) (Not l220 ((i : nat) -> (X-- : lt i O) -> P i)) (λ (i : nat) -> λ (lti0 : lt i O) -> False-ind lzero l220 (λ (X-x-66 : False lzero) -> P i) (absurd lzero (lt i O) lti0 (le-to-not-lt O i (le-O-n i))))) (λ (m : nat) -> λ (X-clearme : decidable l220 ((i : nat) -> (X-- : lt i m) -> P i)) -> match-Or l220 l220 ((i : nat) -> (X-- : lt i m) -> P i) (Not l220 ((i : nat) -> (X-- : lt i m) -> P i)) l220 (λ (X-- : Or l220 l220 ((i : nat) -> (X-- : lt i m) -> P i) (Not l220 ((i : nat) -> (X-- : lt i m) -> P i))) -> decidable l220 ((i : nat) -> (X--1 : lt i (S m)) -> P i)) (λ (H : (i : nat) -> (X-- : lt i m) -> P i) -> match-Or l220 l220 (P m) (Not l220 (P m)) l220 (λ (X-- : Or l220 l220 (P m) (Not l220 (P m))) -> decidable l220 ((i : nat) -> (X--1 : lt i (S m)) -> P i)) (λ (HPm : P m) -> or-introl l220 l220 ((i : nat) -> (X-- : lt i (S m)) -> P i) (Not l220 ((i : nat) -> (X-- : lt i (S m)) -> P i)) (λ (i : nat) -> λ (lei0 : lt i (S m)) -> match-Or lzero lzero (lt (S i) (S m)) (eq lzero nat (S i) (S m)) l220 (λ (X-- : Or lzero lzero (lt (S i) (S m)) (eq lzero nat (S i) (S m))) -> P i) (λ (H1 : lt (S i) (S m)) -> H i (le-S-S-to-le (S i) m H1)) (λ (H1 : eq lzero nat (S i) (S m)) -> eq-ind-r lzero l220 nat m (λ (x : nat) -> λ (X-- : eq lzero nat x m) -> P x) HPm i (injective-S i m H1)) (le-to-or-lt-eq (S i) (S m) lei0))) (λ (HPm : Not l220 (P m)) -> or-intror l220 l220 ((i : nat) -> (X-- : lt i (S m)) -> P i) (Not l220 ((i : nat) -> (X-- : lt i (S m)) -> P i)) (not-to-not l220 ((i : nat) -> (X-- : lt i (S m)) -> P i) (P m) (λ (H1 : (i : nat) -> (X-- : lt i (S m)) -> P i) -> H1 m (eq-coerc lzero (lt m (plus (plus m O) (S O))) (lt m (S m)) (lt-plus-Sn-r m O O) (rewrite-l lzero (lsuc lzero) nat m (λ (X-- : nat) -> eq (lsuc lzero) (Set (lzero)) (lt m (plus X-- (S O))) (lt m (S m))) (rewrite-l lzero (lsuc lzero) nat (S m) (λ (X-- : nat) -> eq (lsuc lzero) (Set (lzero)) (lt m X--) (lt m (S m))) (refl (lsuc lzero) (Set (lzero)) (lt m (S m))) (plus m (S O)) (rewrite-r lzero lzero nat (plus m O) (λ (X-- : nat) -> eq lzero nat (S X--) (plus m (S O))) (plus-n-Sm m O) m (plus-n-O m))) (plus m O) (plus-n-O m)))) HPm)) (Hdec m)) (λ (H : Not l220 ((i : nat) -> (X-- : lt i m) -> P i)) -> or-intror l220 l220 ((i : nat) -> (X-- : lt i (S m)) -> P i) (Not l220 ((i : nat) -> (X-- : lt i (S m)) -> P i)) (not-to-not l220 ((i : nat) -> (X-- : lt i (S m)) -> P i) ((i : nat) -> (X-- : lt i m) -> P i) (λ (H1 : (i : nat) -> (X-- : lt i (S m)) -> P i) -> λ (i : nat) -> λ (leim : lt i m) -> H1 i (le-S (S i) m leim)) H)) X-clearme) n

not-exists-to-forall : (l145 : Level) -> (P : (X-- : nat) -> Set l145) -> (n : nat) -> (X-- : Not l145 (ex lzero l145 nat (λ (i : nat) -> And lzero l145 (lt i n) (P i)))) -> (i : nat) -> (X--1 : lt i n) -> Not l145 (P i)
not-exists-to-forall = λ (l145 : Level) -> λ (P : (X-- : nat) -> Set l145) -> λ (n : nat) -> nat-ind l145 (λ (X-x-365 : nat) -> (X-- : Not l145 (ex lzero l145 nat (λ (i : nat) -> And lzero l145 (lt i X-x-365) (P i)))) -> (i : nat) -> (X--1 : lt i X-x-365) -> Not l145 (P i)) (λ (X-- : Not l145 (ex lzero l145 nat (λ (i : nat) -> And lzero l145 (lt i O) (P i)))) -> λ (i : nat) -> λ (lti0 : lt i O) -> False-ind lzero l145 (λ (X-x-66 : False lzero) -> Not l145 (P i)) (absurd lzero (lt i O) lti0 (le-to-not-lt O i (le-O-n i)))) (λ (m : nat) -> λ (Hind : (X-- : Not l145 (ex lzero l145 nat (λ (i : nat) -> And lzero l145 (lt i m) (P i)))) -> (i : nat) -> (X--1 : lt i m) -> Not l145 (P i)) -> λ (H1 : Not l145 (ex lzero l145 nat (λ (i : nat) -> And lzero l145 (lt i (S m)) (P i)))) -> λ (i : nat) -> λ (leiS : lt i (S m)) -> match-Or lzero lzero (lt (S i) (S m)) (eq lzero nat (S i) (S m)) l145 (λ (X-- : Or lzero lzero (lt (S i) (S m)) (eq lzero nat (S i) (S m))) -> Not l145 (P i)) (λ (H2 : lt (S i) (S m)) -> Hind (not-to-not l145 (ex lzero l145 nat (λ (i0 : nat) -> And lzero l145 (lt i0 m) (P i0))) (ex lzero l145 nat (λ (i0 : nat) -> And lzero l145 (lt i0 (S m)) (P i0))) (λ (X-clearme : ex lzero l145 nat (λ (i0 : nat) -> And lzero l145 (lt i0 m) (P i0))) -> match-ex lzero l145 nat (λ (i0 : nat) -> And lzero l145 (lt i0 m) (P i0)) l145 (λ (X-- : ex lzero l145 nat (λ (i0 : nat) -> And lzero l145 (lt i0 m) (P i0))) -> ex lzero l145 nat (λ (i0 : nat) -> And lzero l145 (lt i0 (S m)) (P i0))) (λ (a : nat) -> λ (X-clearme0 : And lzero l145 (lt a m) (P a)) -> match-And lzero l145 (lt a m) (P a) l145 (λ (X-- : And lzero l145 (lt a m) (P a)) -> ex lzero l145 nat (λ (i0 : nat) -> And lzero l145 (lt i0 (S m)) (P i0))) (λ (leam : lt a m) -> λ (Pa : P a) -> ex-intro lzero l145 nat (λ (i0 : nat) -> And lzero l145 (lt i0 (S m)) (P i0)) a (conj lzero l145 (lt a (S m)) (P a) (le-S (S a) m leam) Pa)) X-clearme0) X-clearme) H1) i (le-S-S-to-le (S i) m H2)) (λ (H2 : eq lzero nat (S i) (S m)) -> not-to-not l145 (P i) (ex lzero l145 nat (λ (i0 : nat) -> And lzero l145 (lt i0 (S m)) (P i0))) (λ (Pi : P i) -> ex-intro lzero l145 nat (λ (i0 : nat) -> And lzero l145 (lt i0 (S m)) (P i0)) i (conj lzero l145 (lt i (S m)) (P i) leiS Pi)) H1) (le-to-or-lt-eq (S i) (S m) leiS)) n

not-forall-to-exists : (l244 : Level) -> (P : (X-- : nat) -> Set l244) -> (n : nat) -> (X-- : (i : nat) -> decidable l244 (P i)) -> (X--1 : Not l244 ((i : nat) -> (X--1 : lt i n) -> P i)) -> ex lzero l244 nat (λ (i : nat) -> And lzero l244 (lt i n) (Not l244 (P i)))
not-forall-to-exists = λ (l244 : Level) -> λ (P : (X-- : nat) -> Set l244) -> λ (n : nat) -> λ (decP : (i : nat) -> decidable l244 (P i)) -> nat-ind l244 (λ (X-x-365 : nat) -> (X-- : Not l244 ((i : nat) -> (X-- : lt i X-x-365) -> P i)) -> ex lzero l244 nat (λ (i : nat) -> And lzero l244 (lt i X-x-365) (Not l244 (P i)))) (λ (X-clearme : Not l244 ((i : nat) -> (X-- : lt i O) -> P i)) -> match-Not l244 ((i : nat) -> (X-- : lt i O) -> P i) l244 (λ (X-- : Not l244 ((i : nat) -> (X-- : lt i O) -> P i)) -> ex lzero l244 nat (λ (i : nat) -> And lzero l244 (lt i O) (Not l244 (P i)))) (λ (H : (X-- : (i : nat) -> (X-- : lt i O) -> P i) -> False l244) -> False-ind l244 l244 (λ (X-x-66 : False l244) -> ex lzero l244 nat (λ (i : nat) -> And lzero l244 (lt i O) (Not l244 (P i)))) (H (λ (i : nat) -> λ (lti0 : lt i O) -> False-ind lzero l244 (λ (X-x-66 : False lzero) -> P i) (absurd lzero (lt i O) lti0 (le-to-not-lt O i (le-O-n i)))))) X-clearme) (λ (m : nat) -> λ (Hind : (X-- : Not l244 ((i : nat) -> (X-- : lt i m) -> P i)) -> ex lzero l244 nat (λ (i : nat) -> And lzero l244 (lt i m) (Not l244 (P i)))) -> λ (H1 : Not l244 ((i : nat) -> (X-- : lt i (S m)) -> P i)) -> match-Or l244 l244 (P m) (Not l244 (P m)) l244 (λ (X-- : Or l244 l244 (P m) (Not l244 (P m))) -> ex lzero l244 nat (λ (i : nat) -> And lzero l244 (lt i (S m)) (Not l244 (P i)))) (λ (H2 : P m) -> match-ex lzero l244 nat (λ (i : nat) -> And lzero l244 (lt i m) (Not l244 (P i))) l244 (λ (X-- : ex lzero l244 nat (λ (i : nat) -> And lzero l244 (lt i m) (Not l244 (P i)))) -> ex lzero l244 nat (λ (i : nat) -> And lzero l244 (lt i (S m)) (Not l244 (P i)))) (λ (i : nat) -> λ (X-clearme : And lzero l244 (lt i m) (Not l244 (P i))) -> match-And lzero l244 (lt i m) (Not l244 (P i)) l244 (λ (X-- : And lzero l244 (lt i m) (Not l244 (P i))) -> ex lzero l244 nat (λ (i0 : nat) -> And lzero l244 (lt i0 (S m)) (Not l244 (P i0)))) (λ (leim : lt i m) -> λ (nPi : Not l244 (P i)) -> ex-intro lzero l244 nat (λ (i0 : nat) -> And lzero l244 (lt i0 (S m)) (Not l244 (P i0))) i (conj lzero l244 (lt i (S m)) (Not l244 (P i)) (le-S (S i) m leim) nPi)) X-clearme) (Hind (not-to-not l244 ((i : nat) -> (X-- : lt i m) -> P i) ((i : nat) -> (X-- : lt i (S m)) -> P i) (λ (H3 : (i : nat) -> (X-- : lt i m) -> P i) -> λ (i : nat) -> λ (leiS : lt i (S m)) -> match-Or lzero lzero (lt (S i) (S m)) (eq lzero nat (S i) (S m)) l244 (λ (X-- : Or lzero lzero (lt (S i) (S m)) (eq lzero nat (S i) (S m))) -> P i) (λ (ltiS : lt (S i) (S m)) -> H3 i (le-S-S-to-le (S i) m ltiS)) (λ (eqi : eq lzero nat (S i) (S m)) -> eq-coerc l244 (P m) (P i) H2 (rewrite-l lzero ((lsuc lzero) ⊔ (lsuc l244)) nat i (λ (X-- : nat) -> eq ((lsuc lzero) ⊔ (lsuc l244)) (Set l244) (P X--) (P i)) (refl ((lsuc lzero) ⊔ (lsuc l244)) (Set l244) (P i)) m (rewrite-r lzero lzero nat (pred (S m)) (λ (X-- : nat) -> eq lzero nat i X--) (rewrite-l lzero lzero nat (S i) (λ (X-- : nat) -> eq lzero nat i (pred X--)) (pred-Sn i) (S m) eqi) m (pred-Sn m)))) (le-to-or-lt-eq (S i) (S m) leiS)) H1))) (λ (H2 : Not l244 (P m)) -> ex-intro lzero l244 nat (λ (i : nat) -> And lzero l244 (lt i (S m)) (Not l244 (P i))) m (conj lzero l244 (lt m (S m)) (Not l244 (P m)) (eq-coerc lzero (lt m (plus (plus m O) (S O))) (lt m (S m)) (lt-plus-Sn-r m O O) (rewrite-l lzero (lsuc lzero) nat m (λ (X-- : nat) -> eq (lsuc lzero) (Set (lzero)) (lt m (plus X-- (S O))) (lt m (S m))) (rewrite-l lzero (lsuc lzero) nat (S m) (λ (X-- : nat) -> eq (lsuc lzero) (Set (lzero)) (lt m X--) (lt m (S m))) (refl (lsuc lzero) (Set (lzero)) (lt m (S m))) (plus m (S O)) (rewrite-r lzero lzero nat (plus m O) (λ (X-- : nat) -> eq lzero nat (S X--) (plus m (S O))) (plus-n-Sm m O) m (plus-n-O m))) (plus m O) (plus-n-O m))) H2)) (decP m)) n

