open import Agda.Primitive
open import matita-arithmetics-congruence
open import matita-arithmetics-gcd
open import matita-arithmetics-permutation
open import matita-arithmetics-div-and-mod
open import matita-arithmetics-sigma-pi
open import matita-arithmetics-bigops
open import matita-basics-bool
open import matita-arithmetics-exp
open import matita-arithmetics-factorial
open import matita-basics-logic
open import matita-arithmetics-primes
open import matita-arithmetics-nat
permut-S-mod : (n : nat) -> permut (S-mod (S n)) n
permut-S-mod = λ (n : nat) -> conj lzero lzero ((i : nat) -> (X-- : le i n) -> le (S-mod (S n) i) n) (injn (S-mod (S n)) n) (λ (i : nat) -> λ (lein : le i n) -> le-S-S-to-le (S-mod (S n) i) n (lt-mod-m-m (S i) (S n) (lt-O-S n))) (λ (i : nat) -> λ (j : nat) -> λ (lein : le i n) -> λ (lejn : le j n) -> λ (Heq : eq lzero nat (S-mod (S n) i) (S-mod (S n) j)) -> injective-S i j (eq-ind lzero lzero nat (mod i (S n)) (λ (x-1 : nat) -> λ (X-x-2 : eq lzero nat (mod i (S n)) x-1) -> eq lzero nat (S x-1) (S j)) (eq-ind lzero lzero nat (mod j (S n)) (λ (x-1 : nat) -> λ (X-x-2 : eq lzero nat (mod j (S n)) x-1) -> eq lzero nat (S (mod i (S n))) (S x-1)) (match-Or lzero lzero (lt i n) (eq lzero nat i n) lzero (λ (X-- : Or lzero lzero (lt i n) (eq lzero nat i n)) -> eq lzero nat (S (mod i (S n))) (S (mod j (S n)))) (λ (Hi : lt i n) -> match-Or lzero lzero (lt j n) (eq lzero nat j n) lzero (λ (X-- : Or lzero lzero (lt j n) (eq lzero nat j n)) -> eq lzero nat (S (mod i (S n))) (S (mod j (S n)))) (λ (Hj : lt j n) -> eq-ind lzero lzero nat (mod (S i) (S n)) (λ (x-1 : nat) -> λ (X-x-2 : eq lzero nat (mod (S i) (S n)) x-1) -> eq lzero nat x-1 (S (mod j (S n)))) (eq-ind lzero lzero nat (mod (S j) (S n)) (λ (x-1 : nat) -> λ (X-x-2 : eq lzero nat (mod (S j) (S n)) x-1) -> eq lzero nat (mod (S i) (S n)) x-1) Heq (S (mod j (S n))) (mod-S j (S n) (lt-O-S n) (le-S-S (S (mod j (S n))) n (eq-ind-r lzero lzero nat j (λ (x : nat) -> λ (X-- : eq lzero nat x j) -> le (S x) n) Hj (mod j (S n)) (lt-to-eq-mod j (S n) (le-S (S j) n Hj)))))) (S (mod i (S n))) (mod-S i (S n) (lt-O-S n) (le-S-S (S (mod i (S n))) n (eq-ind-r lzero lzero nat i (λ (x : nat) -> λ (X-- : eq lzero nat x i) -> le (S x) n) Hi (mod i (S n)) (lt-to-eq-mod i (S n) (le-S (S i) n Hi)))))) (λ (Hj : eq lzero nat j n) -> False-ind lzero lzero (λ (X-x-66 : False lzero) -> eq lzero nat (S (mod i (S n))) (S (mod j (S n)))) (absurd lzero (eq lzero nat O (S (mod i (S n)))) (sym-eq lzero nat (S (mod i (S n))) O (eq-ind lzero lzero nat (mod (S n) (S n)) (λ (x-1 : nat) -> λ (X-x-2 : eq lzero nat (mod (S n) (S n)) x-1) -> eq lzero nat (S (mod i (S n))) x-1) (eq-ind lzero lzero nat j (λ (x-1 : nat) -> λ (X-x-2 : eq lzero nat j x-1) -> eq lzero nat (S (mod i (S n))) (mod (S x-1) (S n))) (eq-ind lzero lzero nat (mod (S i) (S n)) (λ (x-1 : nat) -> λ (X-x-2 : eq lzero nat (mod (S i) (S n)) x-1) -> eq lzero nat x-1 (mod (S j) (S n))) Heq (S (mod i (S n))) (mod-S i (S n) (lt-O-S n) (eq-ind-r lzero lzero nat i (λ (x : nat) -> λ (X-- : eq lzero nat x i) -> lt (S x) (S n)) (le-S-S (S i) n Hi) (mod i (S n)) (lt-to-eq-mod i (S n) (le-S-S i n (lt-to-le i n Hi)))))) n Hj) O (mod-n-n (S n) (lt-O-S n)))) (not-eq-O-S (mod i (S n))))) (le-to-or-lt-eq j n lejn)) (λ (Hi : eq lzero nat i n) -> match-Or lzero lzero (lt j n) (eq lzero nat j n) lzero (λ (X-- : Or lzero lzero (lt j n) (eq lzero nat j n)) -> eq lzero nat (S (mod i (S n))) (S (mod j (S n)))) (λ (Hj : lt j n) -> False-ind lzero lzero (λ (X-x-66 : False lzero) -> eq lzero nat (S (mod i (S n))) (S (mod j (S n)))) (absurd lzero (eq lzero nat O (S (mod j (S n)))) (eq-ind lzero lzero nat (mod (S n) (S n)) (λ (x-1 : nat) -> λ (X-x-2 : eq lzero nat (mod (S n) (S n)) x-1) -> eq lzero nat x-1 (S (mod j (S n)))) (eq-ind lzero lzero nat i (λ (x-1 : nat) -> λ (X-x-2 : eq lzero nat i x-1) -> eq lzero nat (mod (S x-1) (S n)) (S (mod j (S n)))) (eq-ind lzero lzero nat (mod (S j) (S n)) (λ (x-1 : nat) -> λ (X-x-2 : eq lzero nat (mod (S j) (S n)) x-1) -> eq lzero nat (mod (S i) (S n)) x-1) Heq (S (mod j (S n))) (mod-S j (S n) (lt-O-S n) (eq-ind-r lzero lzero nat j (λ (x : nat) -> λ (X-- : eq lzero nat x j) -> lt (S x) (S n)) (le-S-S (S j) n Hj) (mod j (S n)) (lt-to-eq-mod j (S n) (le-S-S j n (lt-to-le j n Hj)))))) n Hi) O (mod-n-n (S n) (lt-O-S n))) (not-eq-O-S (mod j (S n))))) (λ (Hj : eq lzero nat j n) -> eq-ind-r lzero lzero nat n (λ (x : nat) -> λ (X-- : eq lzero nat x n) -> eq lzero nat (S (mod x (S n))) (S (mod j (S n)))) (eq-ind-r lzero lzero nat n (λ (x : nat) -> λ (X-- : eq lzero nat x n) -> eq lzero nat (S (mod n (S n))) (S (mod x (S n)))) (refl lzero nat (S (mod n (S n)))) j Hj) i Hi) (le-to-or-lt-eq j n lejn)) (le-to-or-lt-eq i n lein)) j (lt-to-eq-mod j (S n) (le-S-S j n lejn))) i (lt-to-eq-mod i (S n) (le-S-S i n lein))))

prime-to-not-divides-fact : (p : nat) -> (X-- : prime p) -> (n : nat) -> (X--1 : lt n p) -> Not lzero (divides p (fact n))
prime-to-not-divides-fact = λ (p : nat) -> λ (primep : prime p) -> λ (n : nat) -> nat-ind lzero (λ (X-x-365 : nat) -> (X-- : lt X-x-365 p) -> Not lzero (divides p (fact X-x-365))) (λ (X-- : le (S O) p) -> nmk lzero (divides p (S O)) (λ (divp : divides p (S O)) -> absurd lzero (le p (S O)) (divides-to-le p (S O) (lt-O-S O) divp) (lt-to-not-le (S O) p (prime-to-lt-SO p primep)))) (λ (n1 : nat) -> λ (Hind : (X-- : lt n1 p) -> Not lzero (divides p (fact n1))) -> λ (ltn1 : lt (S n1) p) -> nmk lzero (divides p (times (fact n1) (S n1))) (λ (Hdiv : divides p (times (fact n1) (S n1))) -> match-Or lzero lzero (divides p (fact n1)) (divides p (S n1)) lzero (λ (X-- : Or lzero lzero (divides p (fact n1)) (divides p (S n1))) -> False lzero) (λ (Hdiv0 : divides p (fact n1)) -> absurd lzero (divides p (fact n1)) Hdiv0 (Hind (lt-to-le (S n1) p ltn1))) (λ (Hdiv0 : divides p (S n1)) -> absurd lzero (le p (S n1)) (divides-to-le p (S n1) (lt-O-S n1) Hdiv0) (lt-to-not-le (S n1) p ltn1)) (divides-times-to-divides p (fact n1) (S n1) primep Hdiv))) n

permut-mod : (p : nat) -> (a : nat) -> (X-- : prime p) -> (X--1 : Not lzero (divides p a)) -> permut (λ (n : nat) -> mod (times a n) p) (pred p)
permut-mod = λ (p : nat) -> λ (a : nat) -> λ (primep : prime p) -> λ (ndiv : Not lzero (divides p a)) -> conj lzero lzero ((i : nat) -> (X-- : le i (pred p)) -> le (mod (times a i) p) (pred p)) (injn (λ (n : nat) -> mod (times a n) p) (pred p)) (λ (i : nat) -> λ (lei : le i (pred p)) -> le-S-S-to-le (mod (times a i) p) (pred p) (transitive-le (S (mod (times a i) p)) p (S (pred p)) (lt-mod-m-m (times a i) p (prime-to-lt-O p primep)) (eq-ind-r lzero lzero nat p (λ (x : nat) -> λ (X-- : eq lzero nat x p) -> le p x) (le-n p) (S (pred p)) (S-pred p (prime-to-lt-O p primep))))) (λ (i : nat) -> λ (j : nat) -> λ (lei : le i (pred p)) -> λ (lej : le j (pred p)) -> λ (H : eq lzero nat (mod (times a i) p) (mod (times a j) p)) -> match-Or lzero lzero (lt i j) (Not lzero (lt i j)) lzero (λ (X-- : Or lzero lzero (lt i j) (Not lzero (lt i j))) -> eq lzero nat i j) (λ (ltij : lt i j) -> False-ind lzero lzero (λ (X-x-66 : False lzero) -> eq lzero nat i j) (absurd lzero (lt (minus j i) p) (eq-ind lzero lzero nat (S (pred p)) (λ (x-1 : nat) -> λ (X-x-2 : eq lzero nat (S (pred p)) x-1) -> lt (minus j i) x-1) (le-S-S (minus j i) (pred p) (le-plus-to-minus j i (pred p) (transitive-le j (pred p) (plus (pred p) i) lej (le-plus-n-r i (pred p))))) p (S-pred p (prime-to-lt-O p primep))) (le-to-not-lt p (minus j i) (divides-to-le p (minus j i) (lt-plus-to-minus-r O i j ltij) (match-Or lzero lzero (divides p a) (divides p (minus j i)) lzero (λ (X-- : Or lzero lzero (divides p a) (divides p (minus j i))) -> divides p (minus j i)) (λ (Hdiv : divides p a) -> False-ind lzero lzero (λ (X-x-66 : False lzero) -> divides p (minus j i)) (absurd lzero (divides p a) Hdiv ndiv)) (λ (auto : divides p (minus j i)) -> auto) (divides-times-to-divides p a (minus j i) primep (eq-ind-r lzero lzero nat (minus (times a j) (times a i)) (λ (x : nat) -> λ (X-- : eq lzero nat x (minus (times a j) (times a i))) -> divides p x) (eq-mod-to-divides (times a j) (times a i) p (prime-to-lt-O p primep) (rewrite-l lzero lzero nat (mod (times a i) p) (λ (X-- : nat) -> eq lzero nat X-- (mod (times a i) p)) (refl lzero nat (mod (times a i) p)) (mod (times a j) p) H)) (times a (minus j i)) (distributive-times-minus a j i)))))))) (λ (Hij : Not lzero (lt i j)) -> match-Or lzero lzero (lt j i) (eq lzero nat j i) lzero (λ (X-- : Or lzero lzero (lt j i) (eq lzero nat j i)) -> eq lzero nat i j) (λ (Hij0 : lt j i) -> False-ind lzero lzero (λ (X-x-66 : False lzero) -> eq lzero nat i j) (absurd lzero (lt (minus i j) p) (eq-ind lzero lzero nat (S (pred p)) (λ (x-1 : nat) -> λ (X-x-2 : eq lzero nat (S (pred p)) x-1) -> lt (minus i j) x-1) (le-S-S (minus i j) (pred p) (le-plus-to-minus i j (pred p) (transitive-le i (pred p) (plus (pred p) j) lei (le-plus-n-r j (pred p))))) p (S-pred p (prime-to-lt-O p primep))) (le-to-not-lt p (minus i j) (divides-to-le p (minus i j) (lt-plus-to-minus-r O j i Hij0) (match-Or lzero lzero (divides p a) (divides p (minus i j)) lzero (λ (X-- : Or lzero lzero (divides p a) (divides p (minus i j))) -> divides p (minus i j)) (λ (Hdiv : divides p a) -> False-ind lzero lzero (λ (X-x-66 : False lzero) -> divides p (minus i j)) (absurd lzero (divides p a) Hdiv ndiv)) (λ (auto : divides p (minus i j)) -> auto) (divides-times-to-divides p a (minus i j) primep (eq-ind-r lzero lzero nat (minus (times a i) (times a j)) (λ (x : nat) -> λ (X-- : eq lzero nat x (minus (times a i) (times a j))) -> divides p x) (eq-mod-to-divides (times a i) (times a j) p (prime-to-lt-O p primep) (rewrite-l lzero lzero nat (mod (times a i) p) (λ (X-- : nat) -> eq lzero nat (mod (times a i) p) X--) (refl lzero nat (mod (times a i) p)) (mod (times a j) p) H)) (times a (minus i j)) (distributive-times-minus a i j)))))))) (λ (Hij0 : eq lzero nat j i) -> rewrite-r lzero lzero nat i (λ (X-- : nat) -> eq lzero nat i X--) (refl lzero nat i) j Hij0) (le-to-or-lt-eq j i (not-lt-to-le i j Hij))) (decidable-lt i j))

eq-fact-pi-p' : (n : nat) -> eq lzero nat (fact n) (bigop (minus (S n) (S O)) (λ (i : nat) -> true) nat (S O) times (λ (i : nat) -> plus i (S O)))
eq-fact-pi-p' = λ (n : nat) -> nat-ind lzero (λ (X-x-365 : nat) -> eq lzero nat (fact X-x-365) (bigop (minus (S X-x-365) (S O)) (λ (i : nat) -> true) nat (S O) times (λ (i : nat) -> plus i (S O)))) (refl lzero nat (fact O)) (λ (n1 : nat) -> λ (Hind : eq lzero nat (fact n1) (bigop (minus (S n1) (S O)) (λ (i : nat) -> true) nat (S O) times (λ (i : nat) -> plus i (S O)))) -> eq-ind-r lzero lzero nat (times (S n1) (fact n1)) (λ (x : nat) -> λ (X-- : eq lzero nat x (times (S n1) (fact n1))) -> eq lzero nat x (bigop (minus (S (S n1)) (S O)) (λ (i : nat) -> true) nat (S O) times (λ (i : nat) -> plus i (S O)))) (eq-ind-r lzero lzero nat (times (plus n1 (S O)) (bigop n1 (λ (i : nat) -> true) nat (S O) times (λ (i : nat) -> plus i (S O)))) (λ (x : nat) -> λ (X-- : eq lzero nat x (times (plus n1 (S O)) (bigop n1 (λ (i : nat) -> true) nat (S O) times (λ (i : nat) -> plus i (S O))))) -> eq lzero nat (times (S n1) (fact n1)) x) (eq-ind lzero lzero nat (S (plus n1 O)) (λ (x-1 : nat) -> λ (X-x-2 : eq lzero nat (S (plus n1 O)) x-1) -> eq lzero nat (times (S n1) (fact n1)) (times x-1 (bigop n1 (λ (i : nat) -> true) nat (S O) times (λ (i : nat) -> plus i (S O))))) (eq-ind lzero lzero nat n1 (λ (x-1 : nat) -> λ (X-x-2 : eq lzero nat n1 x-1) -> eq lzero nat (times (S n1) (fact n1)) (times (S x-1) (bigop n1 (λ (i : nat) -> true) nat (S O) times (λ (i : nat) -> plus i (S O))))) (eq-f lzero lzero nat nat (times (S n1)) (fact n1) (bigop n1 (λ (i : nat) -> true) nat (S O) times (λ (i : nat) -> plus i (S O))) (eq-ind lzero lzero nat (minus (S n1) (S O)) (λ (x-1 : nat) -> λ (X-x-2 : eq lzero nat (minus (S n1) (S O)) x-1) -> eq lzero nat (fact n1) (bigop x-1 (λ (i : nat) -> true) nat (S O) times (λ (i : nat) -> plus i (S O)))) Hind n1 (rewrite-l lzero lzero nat n1 (λ (X-- : nat) -> eq lzero nat X-- n1) (refl lzero nat n1) (minus n1 O) (minus-n-O n1)))) (plus n1 O) (plus-n-O n1)) (plus n1 (S O)) (plus-n-Sm n1 O)) (bigop (S n1) (λ (i : nat) -> true) nat (S O) times (λ (i : nat) -> plus i (S O))) (bigop-Strue n1 (λ (X-- : nat) -> true) nat (S O) times (λ (X-- : nat) -> plus X-- (S O)) (refl lzero bool true))) (times (fact n1) (S n1)) (commutative-times (fact n1) (S n1))) n

congruent-pi : (f : (X-- : nat) -> nat) -> (n : nat) -> (p : nat) -> (X-- : lt O p) -> congruent (bigop n (λ (i : nat) -> true) nat (S O) times (λ (i : nat) -> f i)) (bigop n (λ (i : nat) -> true) nat (S O) times (λ (i : nat) -> mod (f i) p)) p
congruent-pi = λ (f : (X-- : nat) -> nat) -> λ (n : nat) -> nat-ind lzero (λ (X-x-365 : nat) -> (p : nat) -> (X-- : lt O p) -> congruent (bigop X-x-365 (λ (i : nat) -> true) nat (S O) times (λ (i : nat) -> f i)) (bigop X-x-365 (λ (i : nat) -> true) nat (S O) times (λ (i : nat) -> mod (f i) p)) p) (λ (p : nat) -> λ (auto : lt O p) -> congruent-n-n (bigop O (λ (i : nat) -> true) nat (S O) times (λ (i : nat) -> f i)) p) (λ (n1 : nat) -> λ (Hind : (p : nat) -> (X-- : lt O p) -> congruent (bigop n1 (λ (i : nat) -> true) nat (S O) times (λ (i : nat) -> f i)) (bigop n1 (λ (i : nat) -> true) nat (S O) times (λ (i : nat) -> mod (f i) p)) p) -> λ (p : nat) -> λ (posp : lt O p) -> eq-ind-r lzero lzero nat (times (f n1) (bigop n1 (λ (i : nat) -> true) nat (S O) times (λ (i : nat) -> f i))) (λ (x : nat) -> λ (X-- : eq lzero nat x (times (f n1) (bigop n1 (λ (i : nat) -> true) nat (S O) times (λ (i : nat) -> f i)))) -> congruent x (bigop (S n1) (λ (i : nat) -> true) nat (S O) times (λ (i : nat) -> mod (f i) p)) p) (congruent-times (f n1) (bigop n1 (λ (i : nat) -> true) nat (S O) times (λ (i : nat) -> f i)) (mod (f n1) p) (bigop n1 (λ (i : nat) -> true) nat (S O) times (λ (i : nat) -> mod (f i) p)) p posp (congruent-n-mod-n (f n1) p posp) (Hind p posp)) (bigop (S n1) (λ (i : nat) -> true) nat (S O) times (λ (i : nat) -> f i)) (bigop-Strue n1 (λ (X-- : nat) -> true) nat (S O) times f (refl lzero bool true))) n

congruent-exp-pred-SO : (p : nat) -> (a : nat) -> (X-- : prime p) -> (X--1 : Not lzero (divides p a)) -> congruent (exp a (pred p)) (S O) p
congruent-exp-pred-SO = λ (p : nat) -> λ (a : nat) -> λ (primep : prime p) -> λ (ndiv : Not lzero (divides p a)) -> divides-to-congruent (exp a (pred p)) (S O) p (prime-to-lt-O p primep) (lt-O-exp a (pred p) (match-nat lzero (λ (X-- : nat) -> (X--1 : Not lzero (divides p X--)) -> lt O X--) (λ (X-clearme : Not lzero (divides p O)) -> match-Not lzero (divides p O) lzero (λ (X-- : Not lzero (divides p O)) -> lt O O) (λ (div0 : (X-- : divides p O) -> False lzero) -> False-ind lzero lzero (λ (X-x-66 : False lzero) -> lt O O) (div0 (quotient p O O (rewrite-l lzero lzero nat O (λ (X-- : nat) -> eq lzero nat O X--) (refl lzero nat O) (times p O) (times-n-O p))))) X-clearme) (λ (auto : nat) -> λ (auto' : Not lzero (divides p (S auto))) -> lt-O-S auto) a ndiv)) (match-Or lzero lzero (divides p (minus (exp a (pred p)) (S O))) (divides p (fact (pred p))) lzero (λ (X-- : Or lzero lzero (divides p (minus (exp a (pred p)) (S O))) (divides p (fact (pred p)))) -> divides p (minus (exp a (pred p)) (S O))) (λ (auto : divides p (minus (exp a (pred p)) (S O))) -> auto) (λ (Hdiv : divides p (fact (pred p))) -> False-ind lzero lzero (λ (X-x-66 : False lzero) -> divides p (minus (exp a (pred p)) (S O))) (absurd lzero (divides p (fact (pred p))) Hdiv (prime-to-not-divides-fact p primep (pred p) (le-S-S-to-le (S (pred p)) p (eq-ind-r lzero lzero nat p (λ (x : nat) -> λ (X-- : eq lzero nat x p) -> le (S x) (S p)) (le-n (S p)) (S (pred p)) (S-pred p (prime-to-lt-O p primep))))))) (divides-times-to-divides p (minus (exp a (pred p)) (S O)) (fact (pred p)) primep (eq-ind-r lzero lzero nat (times (fact (pred p)) (minus (exp a (pred p)) (S O))) (λ (x : nat) -> λ (X-- : eq lzero nat x (times (fact (pred p)) (minus (exp a (pred p)) (S O)))) -> divides p x) (eq-ind-r lzero lzero nat (minus (times (fact (pred p)) (exp a (pred p))) (times (fact (pred p)) (S O))) (λ (x : nat) -> λ (X-- : eq lzero nat x (minus (times (fact (pred p)) (exp a (pred p))) (times (fact (pred p)) (S O)))) -> divides p x) (eq-ind lzero lzero nat (fact (pred p)) (λ (x-1 : nat) -> λ (X-x-2 : eq lzero nat (fact (pred p)) x-1) -> divides p (minus (times (fact (pred p)) (exp a (pred p))) x-1)) (eq-ind-r lzero lzero nat (bigop (minus (S (pred p)) (S O)) (λ (i : nat) -> true) nat (S O) times (λ (i : nat) -> plus i (S O))) (λ (x : nat) -> λ (X-- : eq lzero nat x (bigop (minus (S (pred p)) (S O)) (λ (i : nat) -> true) nat (S O) times (λ (i : nat) -> plus i (S O)))) -> divides p (minus (times x (exp a (pred p))) x)) (eq-ind-r lzero lzero nat (times (exp a (pred p)) (bigop (minus (S (pred p)) (S O)) (λ (i : nat) -> true) nat (S O) times (λ (i : nat) -> plus i (S O)))) (λ (x : nat) -> λ (X-- : eq lzero nat x (times (exp a (pred p)) (bigop (minus (S (pred p)) (S O)) (λ (i : nat) -> true) nat (S O) times (λ (i : nat) -> plus i (S O))))) -> divides p (minus x (bigop (minus (S (pred p)) (S O)) (λ (i : nat) -> true) nat (S O) times (λ (i : nat) -> plus i (S O))))) (eq-ind-r lzero lzero nat (minus (S (pred p)) (S O)) (λ (x : nat) -> λ (X-- : eq lzero nat x (minus (S (pred p)) (S O))) -> divides p (minus (times (exp a x) (bigop (minus (S (pred p)) (S O)) (λ (i : nat) -> true) nat (S O) times (λ (i : nat) -> plus i (S O)))) (bigop (minus (S (pred p)) (S O)) (λ (i : nat) -> true) nat (S O) times (λ (i : nat) -> plus i (S O))))) (eq-ind-r lzero lzero nat (bigop (minus (S (pred p)) (S O)) (λ (i : nat) -> true) nat (S O) times (λ (i : nat) -> times a (plus i (S O)))) (λ (x : nat) -> λ (X-- : eq lzero nat x (bigop (minus (S (pred p)) (S O)) (λ (i : nat) -> true) nat (S O) times (λ (i : nat) -> times a (plus i (S O))))) -> divides p (minus x (bigop (minus (S (pred p)) (S O)) (λ (i : nat) -> true) nat (S O) times (λ (i : nat) -> plus i (S O))))) (congruent-to-divides (bigop (minus (S (pred p)) (S O)) (λ (i : nat) -> true) nat (S O) times (λ (i : nat) -> times a (plus i (S O)))) (bigop (minus (S (pred p)) (S O)) (λ (i : nat) -> true) nat (S O) times (λ (i : nat) -> plus i (S O))) p (prime-to-lt-O p primep) (transitive-congruent p (bigop (minus (S (pred p)) (S O)) (λ (i : nat) -> true) nat (S O) times (λ (i : nat) -> times a (plus i (S O)))) (bigop (minus (S (pred p)) (S O)) (λ (i : nat) -> true) nat (S O) times (λ (i : nat) -> mod (times a (plus i (S O))) p)) (bigop (minus (S (pred p)) (S O)) (λ (i : nat) -> true) nat (S O) times (λ (i : nat) -> plus i (S O))) (congruent-pi (λ (m : nat) -> times a (plus m (S O))) (minus (S (pred p)) (S O)) p (prime-to-lt-O p primep)) (eq-ind lzero lzero nat (bigop (minus (S (pred p)) (S O)) (λ (i : nat) -> true) nat (S O) times (λ (i : nat) -> plus i (S O))) (λ (x-1 : nat) -> λ (X-x-2 : eq lzero nat (bigop (minus (S (pred p)) (S O)) (λ (i : nat) -> true) nat (S O) times (λ (i : nat) -> plus i (S O))) x-1) -> congruent x-1 (bigop (minus (S (pred p)) (S O)) (λ (i : nat) -> true) nat (S O) times (λ (i : nat) -> plus i (S O))) p) (congruent-n-n (bigop (minus (S (pred p)) (S O)) (λ (i : nat) -> true) nat (S O) times (λ (i : nat) -> plus i (S O))) p) (bigop (minus (S (pred p)) (S O)) (λ (i : nat) -> true) nat (S O) times (λ (i : nat) -> mod (times a (plus i (S O))) p)) (eq-ind-r lzero lzero nat (bigop (S (pred p)) (λ (i : nat) -> andb (leb (S O) i) true) nat (S O) (op lzero nat (S O) timesA) (λ (i : nat) -> i)) (λ (x : nat) -> λ (X-- : eq lzero nat x (bigop (S (pred p)) (λ (i : nat) -> andb (leb (S O) i) true) nat (S O) (op lzero nat (S O) timesA) (λ (i : nat) -> i))) -> eq lzero nat x (bigop (minus (S (pred p)) (S O)) (λ (i : nat) -> true) nat (S O) times (λ (i : nat) -> mod (times a (plus i (S O))) p))) (eq-ind-r lzero lzero nat (bigop (S (pred p)) (λ (i : nat) -> andb (leb (S O) i) true) nat (S O) (op lzero nat (S O) timesA) (λ (i : nat) -> mod (times a i) p)) (λ (x : nat) -> λ (X-- : eq lzero nat x (bigop (S (pred p)) (λ (i : nat) -> andb (leb (S O) i) true) nat (S O) (op lzero nat (S O) timesA) (λ (i : nat) -> mod (times a i) p))) -> eq lzero nat (bigop (S (pred p)) (λ (i : nat) -> andb (leb (S O) i) true) nat (S O) (op lzero nat (S O) timesA) (λ (i : nat) -> i)) x) (sym-eq lzero nat (bigop (S (pred p)) (λ (i : nat) -> andb (leb (S O) i) true) nat (S O) (op lzero nat (S O) timesA) (λ (i : nat) -> mod (times a i) p)) (bigop (S (pred p)) (λ (i : nat) -> andb (leb (S O) i) true) nat (S O) (op lzero nat (S O) timesA) (λ (i : nat) -> i)) (bigop-iso (S (pred p)) (S (pred p)) (λ (X-- : nat) -> andb (leb (S O) X--) true) (λ (X-- : nat) -> andb (leb (S O) X--) true) nat (S O) timesAC (λ (X-- : nat) -> mod (times a X--) p) (λ (X-- : nat) -> X--) (ex-intro lzero lzero ((X-- : nat) -> nat) (λ (h : (X-- : nat) -> nat) -> ex lzero lzero ((X-- : nat) -> nat) (λ (k-v : (X-- : nat) -> nat) -> And lzero lzero (And lzero lzero ((i : nat) -> (X-- : lt i (upto nat (mk-range nat (λ (X-0 : nat) -> mod (times a X-0) p) (S (pred p)) (λ (X-0 : nat) -> andb (leb (S O) X-0) true)))) -> (X--1 : eq lzero bool (filter nat (mk-range nat (λ (X-0 : nat) -> mod (times a X-0) p) (S (pred p)) (λ (X-0 : nat) -> andb (leb (S O) X-0) true)) i) true) -> eq lzero nat (enum nat (mk-range nat (λ (X-0 : nat) -> mod (times a X-0) p) (S (pred p)) (λ (X-0 : nat) -> andb (leb (S O) X-0) true)) i) (enum nat (mk-range nat (λ (X-0 : nat) -> X-0) (S (pred p)) (λ (X-0 : nat) -> andb (leb (S O) X-0) true)) (h i))) (sub-hk h k-v nat (mk-range nat (λ (X-0 : nat) -> mod (times a X-0) p) (S (pred p)) (λ (X-0 : nat) -> andb (leb (S O) X-0) true)) (mk-range nat (λ (X-0 : nat) -> X-0) (S (pred p)) (λ (X-0 : nat) -> andb (leb (S O) X-0) true)))) (sub-hk k-v h nat (mk-range nat (λ (X-0 : nat) -> X-0) (S (pred p)) (λ (X-0 : nat) -> andb (leb (S O) X-0) true)) (mk-range nat (λ (X-0 : nat) -> mod (times a X-0) p) (S (pred p)) (λ (X-0 : nat) -> andb (leb (S O) X-0) true))))) (λ (i : nat) -> mod (times a i) p) (ex-intro lzero lzero ((X-- : nat) -> nat) (λ (k-v : (X-- : nat) -> nat) -> And lzero lzero (And lzero lzero ((i : nat) -> (X-- : lt i (S (pred p))) -> (X--1 : eq lzero bool (andb (leb (S O) i) true) true) -> eq lzero nat (mod (times a i) p) (mod (times a i) p)) (sub-hk (λ (i : nat) -> mod (times a i) p) k-v nat (mk-range nat (λ (X-0 : nat) -> mod (times a X-0) p) (S (pred p)) (λ (X-0 : nat) -> andb (leb (S O) X-0) true)) (mk-range nat (λ (X-0 : nat) -> X-0) (S (pred p)) (λ (X-0 : nat) -> andb (leb (S O) X-0) true)))) (sub-hk k-v (λ (i : nat) -> mod (times a i) p) nat (mk-range nat (λ (X-0 : nat) -> X-0) (S (pred p)) (λ (X-0 : nat) -> andb (leb (S O) X-0) true)) (mk-range nat (λ (X-0 : nat) -> mod (times a X-0) p) (S (pred p)) (λ (X-0 : nat) -> andb (leb (S O) X-0) true)))) (invert-permut (pred p) (λ (i : nat) -> mod (times a i) p)) (conj lzero lzero (And lzero lzero ((i : nat) -> (X-- : lt i (S (pred p))) -> (X--1 : eq lzero bool (andb (leb (S O) i) true) true) -> eq lzero nat (mod (times a i) p) (mod (times a i) p)) (sub-hk (λ (i : nat) -> mod (times a i) p) (invert-permut (pred p) (λ (i : nat) -> mod (times a i) p)) nat (mk-range nat (λ (X-0 : nat) -> mod (times a X-0) p) (S (pred p)) (λ (X-0 : nat) -> andb (leb (S O) X-0) true)) (mk-range nat (λ (X-0 : nat) -> X-0) (S (pred p)) (λ (X-0 : nat) -> andb (leb (S O) X-0) true)))) (sub-hk (invert-permut (pred p) (λ (i : nat) -> mod (times a i) p)) (λ (i : nat) -> mod (times a i) p) nat (mk-range nat (λ (X-0 : nat) -> X-0) (S (pred p)) (λ (X-0 : nat) -> andb (leb (S O) X-0) true)) (mk-range nat (λ (X-0 : nat) -> mod (times a X-0) p) (S (pred p)) (λ (X-0 : nat) -> andb (leb (S O) X-0) true))) (conj lzero lzero ((i : nat) -> (X-- : lt i (S (pred p))) -> (X--1 : eq lzero bool (andb (leb (S O) i) true) true) -> eq lzero nat (mod (times a i) p) (mod (times a i) p)) (sub-hk (λ (i : nat) -> mod (times a i) p) (invert-permut (pred p) (λ (i : nat) -> mod (times a i) p)) nat (mk-range nat (λ (X-0 : nat) -> mod (times a X-0) p) (S (pred p)) (λ (X-0 : nat) -> andb (leb (S O) X-0) true)) (mk-range nat (λ (X-0 : nat) -> X-0) (S (pred p)) (λ (X-0 : nat) -> andb (leb (S O) X-0) true))) (λ (i : nat) -> λ (lti : lt i (S (pred p))) -> λ (X-- : eq lzero bool (andb (leb (S O) i) true) true) -> refl lzero nat (mod (times a i) p)) (λ (i : nat) -> λ (lti : lt i (S (pred p))) -> λ (posi : eq lzero bool (andb (leb (S O) i) true) true) -> conj lzero lzero (And lzero lzero (lt (mod (times a i) p) (S (pred p))) (eq lzero bool (andb (leb (S O) (mod (times a i) p)) true) true)) (eq lzero nat (invert-permut (pred p) (λ (i0 : nat) -> mod (times a i0) p) (mod (times a i) p)) i) (conj lzero lzero (lt (mod (times a i) p) (S (pred p))) (eq lzero bool (andb (leb (S O) (mod (times a i) p)) true) true) (eq-ind-r lzero lzero nat p (λ (x : nat) -> λ (X-- : eq lzero nat x p) -> lt (mod (times a i) p) x) (lt-mod-m-m (times a i) p (prime-to-lt-O p primep)) (S (pred p)) (S-pred p (prime-to-lt-O p primep))) (eq-ind-r lzero lzero bool true (λ (x : bool) -> λ (X-- : eq lzero bool x true) -> eq lzero bool (andb x true) true) (refl lzero bool (andb true true)) (leb (S O) (mod (times a i) p)) (le-to-leb-true (S O) (mod (times a i) p) (match-Or lzero lzero (lt O (mod (times a i) p)) (eq lzero nat O (mod (times a i) p)) lzero (λ (X-- : Or lzero lzero (lt O (mod (times a i) p)) (eq lzero nat O (mod (times a i) p))) -> le (S O) (mod (times a i) p)) (λ (auto : lt O (mod (times a i) p)) -> auto) (λ (H : eq lzero nat O (mod (times a i) p)) -> False-ind lzero lzero (λ (X-x-66 : False lzero) -> le (S O) (mod (times a i) p)) (absurd lzero (divides p (times a i)) (mod-O-to-divides p (times a i) (prime-to-lt-O p primep) (sym-eq lzero nat O (mod (times a i) p) H)) (not-to-not lzero (divides p (times a i)) (divides p a) (λ (Hdiv : divides p (times a i)) -> match-Or lzero lzero (divides p a) (divides p i) lzero (λ (X-- : Or lzero lzero (divides p a) (divides p i)) -> divides p a) (λ (auto : divides p a) -> auto) (λ (divpi : divides p i) -> False-ind lzero lzero (λ (X-x-66 : False lzero) -> divides p a) (absurd lzero (lt i (S (pred p))) lti (le-to-not-lt (S (pred p)) i (eq-ind-r lzero lzero nat p (λ (x : nat) -> λ (X-- : eq lzero nat x p) -> le x i) (divides-to-le p i (leb-true-to-le (S O) i (andb-true-l (leb (S O) i) true posi)) divpi) (S (pred p)) (S-pred p (prime-to-lt-O p primep)))))) (divides-times-to-divides p a i primep Hdiv)) ndiv))) (le-to-or-lt-eq O (mod (times a i) p) (le-O-n (mod (times a i) p))))))) (invert-permut-f (λ (i0 : nat) -> mod (times a i0) p) (pred p) i (le-S-S-to-le i (pred p) lti) (match-And lzero lzero ((i1 : nat) -> (X-- : le i1 (pred p)) -> le (mod (times a i1) p) (pred p)) (injn (λ (n : nat) -> mod (times a n) p) (pred p)) lzero (λ (X-- : And lzero lzero ((i0 : nat) -> (X-- : le i0 (pred p)) -> le (mod (times a i0) p) (pred p)) (injn (λ (n : nat) -> mod (times a n) p) (pred p))) -> injn (λ (i0 : nat) -> mod (times a i0) p) (pred p)) (λ (auto : (i0 : nat) -> (X-- : le i0 (pred p)) -> le (mod (times a i0) p) (pred p)) -> λ (auto' : injn (λ (n : nat) -> mod (times a n) p) (pred p)) -> auto') (permut-mod p a primep ndiv))))) (match-And lzero lzero ((i : nat) -> (X-- : le i (pred p)) -> le (invert-permut (pred p) (λ (n : nat) -> mod (times a n) p) i) (pred p)) (injn (invert-permut (pred p) (λ (n : nat) -> mod (times a n) p)) (pred p)) lzero (λ (X-- : And lzero lzero ((i : nat) -> (X-- : le i (pred p)) -> le (invert-permut (pred p) (λ (n : nat) -> mod (times a n) p) i) (pred p)) (injn (invert-permut (pred p) (λ (n : nat) -> mod (times a n) p)) (pred p))) -> sub-hk (invert-permut (pred p) (λ (i : nat) -> mod (times a i) p)) (λ (i : nat) -> mod (times a i) p) nat (mk-range nat (λ (X-0 : nat) -> X-0) (S (pred p)) (λ (X-0 : nat) -> andb (leb (S O) X-0) true)) (mk-range nat (λ (X-0 : nat) -> mod (times a X-0) p) (S (pred p)) (λ (X-0 : nat) -> andb (leb (S O) X-0) true))) (λ (le-invert-permut : (i : nat) -> (X-- : le i (pred p)) -> le (invert-permut (pred p) (λ (n : nat) -> mod (times a n) p) i) (pred p)) -> λ (inj-inv-permut : injn (invert-permut (pred p) (λ (n : nat) -> mod (times a n) p)) (pred p)) -> λ (i : nat) -> λ (lti : lt i (S (pred p))) -> λ (posi : eq lzero bool (andb (leb (S O) i) true) true) -> conj lzero lzero (And lzero lzero (lt (invert-permut (pred p) (λ (i0 : nat) -> mod (times a i0) p) i) (S (pred p))) (eq lzero bool (andb (leb (S O) (invert-permut (pred p) (λ (i0 : nat) -> mod (times a i0) p) i)) true) true)) (eq lzero nat (mod (times a (invert-permut (pred p) (λ (i0 : nat) -> mod (times a i0) p) i)) p) i) (conj lzero lzero (lt (invert-permut (pred p) (λ (i0 : nat) -> mod (times a i0) p) i) (S (pred p))) (eq lzero bool (andb (leb (S O) (invert-permut (pred p) (λ (i0 : nat) -> mod (times a i0) p) i)) true) true) (le-S-S (invert-permut (pred p) (λ (i0 : nat) -> mod (times a i0) p) i) (pred p) (le-invert-permut i (le-S-S-to-le i (pred p) lti))) (eq-ind-r lzero lzero bool true (λ (x : bool) -> λ (X-- : eq lzero bool x true) -> eq lzero bool (andb x true) true) (refl lzero bool (andb true true)) (leb (S O) (invert-permut (pred p) (λ (i0 : nat) -> mod (times a i0) p) i)) (le-to-leb-true (S O) (invert-permut (pred p) (λ (i0 : nat) -> mod (times a i0) p) i) (match-Or lzero lzero (lt O (invert-permut (pred p) (λ (i0 : nat) -> mod (times a i0) p) i)) (eq lzero nat O (invert-permut (pred p) (λ (i0 : nat) -> mod (times a i0) p) i)) lzero (λ (X-- : Or lzero lzero (lt O (invert-permut (pred p) (λ (i0 : nat) -> mod (times a i0) p) i)) (eq lzero nat O (invert-permut (pred p) (λ (i0 : nat) -> mod (times a i0) p) i))) -> le (S O) (invert-permut (pred p) (λ (i0 : nat) -> mod (times a i0) p) i)) (λ (auto : lt O (invert-permut (pred p) (λ (i0 : nat) -> mod (times a i0) p) i)) -> auto) (λ (H : eq lzero nat O (invert-permut (pred p) (λ (i0 : nat) -> mod (times a i0) p) i)) -> False-ind lzero lzero (λ (X-x-66 : False lzero) -> le (S O) (invert-permut (pred p) (λ (i0 : nat) -> mod (times a i0) p) i)) (eq-ind-r lzero lzero nat O (λ (x : nat) -> λ (X-- : eq lzero nat x O) -> (X--1 : eq lzero nat x (mod (times a (invert-permut (pred p) (λ (i0 : nat) -> mod (times a i0) p) i)) p)) -> False lzero) (eq-ind-r lzero lzero nat i (λ (x : nat) -> λ (X-- : eq lzero nat x i) -> (X--1 : eq lzero nat O x) -> False lzero) (λ (eq0i : eq lzero nat O i) -> eq-ind lzero lzero nat O (λ (x-1 : nat) -> λ (X-x-2 : eq lzero nat O x-1) -> (X-- : eq lzero bool (andb (leb (S O) x-1) true) true) -> False lzero) (λ (H0 : eq lzero bool false true) -> bool-discr lzero false true H0 (False lzero)) i eq0i posi) (mod (times a (invert-permut (pred p) (λ (i0 : nat) -> mod (times a i0) p) i)) p) (f-invert-permut (λ (i0 : nat) -> mod (times a i0) p) (pred p) i (le-S-S-to-le i (pred p) lti) (permut-mod p a primep ndiv))) (mod (times a O) p) (eq-ind lzero lzero nat O (λ (x-1 : nat) -> λ (X-x-2 : eq lzero nat O x-1) -> eq lzero nat (mod x-1 p) O) (rewrite-r lzero lzero nat O (λ (X-- : nat) -> eq lzero nat X-- O) (refl lzero nat O) (mod O p) (mod-O-n p)) (times a O) (times-n-O a)) (eq-f lzero lzero nat nat (λ (i0 : nat) -> mod (times a i0) p) O (invert-permut (pred p) (λ (i0 : nat) -> mod (times a i0) p) i) (rewrite-l lzero lzero nat O (λ (X-- : nat) -> eq lzero nat O X--) (refl lzero nat O) (invert-permut (pred p) (λ (i0 : nat) -> mod (times a i0) p) i) H)))) (le-to-or-lt-eq O (invert-permut (pred p) (λ (i0 : nat) -> mod (times a i0) p) i) (le-O-n (invert-permut (pred p) (λ (i0 : nat) -> mod (times a i0) p) i))))))) (f-invert-permut (λ (X-- : nat) -> mod (times a X--) p) (pred p) i (le-S-S-to-le i (pred p) lti) (permut-mod p a primep ndiv))) (permut-invert-permut (λ (n : nat) -> mod (times a n) p) (pred p) (permut-mod p a primep ndiv)))))))) (bigop (minus (S (pred p)) (S O)) (λ (i : nat) -> true) nat (S O) (op lzero nat (S O) timesA) (λ (i : nat) -> mod (times a (plus i (S O))) p)) (bigop-I-gen (S O) (S (pred p)) (λ (X-- : nat) -> true) nat (S O) timesA (λ (X-- : nat) -> mod (times a X--) p) (lt-O-S (pred p)))) (bigop (minus (S (pred p)) (S O)) (λ (i : nat) -> true) nat (S O) (op lzero nat (S O) timesA) (λ (i : nat) -> plus i (S O))) (bigop-I-gen (S O) (S (pred p)) (λ (X-- : nat) -> true) nat (S O) timesA (λ (X-- : nat) -> X--) (lt-O-S (pred p))))))) (times (exp a (minus (S (pred p)) (S O))) (bigop (minus (S (pred p)) (S O)) (λ (i : nat) -> true) nat (S O) times (λ (i : nat) -> plus i (S O)))) (exp-pi-bc a (S O) (S (pred p)) (λ (X-- : nat) -> X--))) (pred p) (rewrite-r lzero lzero nat (minus (pred p) O) (λ (X-- : nat) -> eq lzero nat (pred p) X--) (rewrite-l lzero lzero nat (pred p) (λ (X-- : nat) -> eq lzero nat (pred p) X--) (refl lzero nat (pred p)) (minus (pred p) O) (minus-n-O (pred p))) (minus (S (pred p)) (S O)) (minus-S-S (pred p) O))) (times (bigop (minus (S (pred p)) (S O)) (λ (i : nat) -> true) nat (S O) times (λ (i : nat) -> plus i (S O))) (exp a (pred p))) (commutative-times (bigop (minus (S (pred p)) (S O)) (λ (i : nat) -> true) nat (S O) times (λ (i : nat) -> plus i (S O))) (exp a (pred p)))) (fact (pred p)) (eq-fact-pi-p' (pred p))) (times (fact (pred p)) (S O)) (times-n-1 (fact (pred p)))) (times (fact (pred p)) (minus (exp a (pred p)) (S O))) (distributive-times-minus (fact (pred p)) (exp a (pred p)) (S O))) (times (minus (exp a (pred p)) (S O)) (fact (pred p))) (commutative-times (minus (exp a (pred p)) (S O)) (fact (pred p))))))

