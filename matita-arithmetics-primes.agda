open import Agda.Primitive
open import matita-basics-relations
open import matita-arithmetics-div-and-mod
open import matita-basics-bool
open import matita-arithmetics-factorial
open import matita-arithmetics-minimization
open import matita-basics-logic
open import matita-arithmetics-nat


data divides (n-v : nat) (m-v : nat) : Set (lzero) where
  quotient' : (q-v : nat) -> (X---v : eq lzero nat m-v (times n-v q-v)) -> divides n-v m-v

quotient : (n-v : nat) -> (m-v : nat) -> (q-v : nat) -> (X---v : eq lzero nat m-v (times n-v q-v)) -> divides n-v m-v
quotient _ _ = quotient'


match-divides : (X-n-v : nat) -> (X-m-v : nat) -> (return-sort-v : Level) -> (return-type-v : (z-v : divides X-n-v X-m-v) -> Set return-sort-v) -> (case-quotient-v : (q-v : nat) -> (X---v : eq lzero nat X-m-v (times X-n-v q-v)) -> return-type-v (quotient X-n-v X-m-v q-v X---v)) -> (z-v : divides X-n-v X-m-v) -> return-type-v z-v
match-divides _ _ _ _ case (quotient' x1 x2) = case x1 x2

divides-ind : (l2-v : Level) -> (X-n-v : nat) -> (X-m-v : nat) -> (Q--v : (X-x-1192-v : divides X-n-v X-m-v) -> Set l2-v) -> (X-H-quotient-v : (q-v : nat) -> (x-1193-v : eq lzero nat X-m-v (times X-n-v q-v)) -> Q--v (quotient X-n-v X-m-v q-v x-1193-v)) -> (x-1192-v : divides X-n-v X-m-v) -> Q--v x-1192-v
divides-ind _ _ _ _ case (quotient' x1 x2) = case x1 x2


divides-inv-ind : (l14 : Level) -> (x1 : nat) -> (x2 : nat) -> (Hterm : divides x1 x2) -> (P : (X-z2006 : divides x1 x2) -> Set l14) -> (X-H1 : (q : nat) -> (x-1193 : eq lzero nat x2 (times x1 q)) -> (X-z2007 : eq lzero (divides x1 x2) Hterm (quotient x1 x2 q x-1193)) -> P (quotient x1 x2 q x-1193)) -> P Hterm
divides-inv-ind = λ (l14 : Level) -> λ (x1 : nat) -> λ (x2 : nat) -> λ (Hterm : divides x1 x2) -> λ (P : (X-z2006 : divides x1 x2) -> Set l14) -> λ (H1 : (q : nat) -> (x-1193 : eq lzero nat x2 (times x1 q)) -> (X-z2007 : eq lzero (divides x1 x2) Hterm (quotient x1 x2 q x-1193)) -> P (quotient x1 x2 q x-1193)) -> divides-ind l14 x1 x2 (λ (X-x-1192 : divides x1 x2) -> (X-z2007 : eq lzero (divides x1 x2) Hterm X-x-1192) -> P X-x-1192) H1 Hterm (refl lzero (divides x1 x2) Hterm)

reflexive-divides : reflexive lzero lzero nat divides
reflexive-divides = λ (x : nat) -> quotient x x (S O) (rewrite-r lzero lzero nat (times x (S O)) (λ (X-- : nat) -> eq lzero nat X-- (times x (S O))) (refl lzero nat (times x (S O))) x (times-n-1 x))

divides-to-div-mod-spec : (n : nat) -> (m : nat) -> (X-- : lt O n) -> (X--1 : divides n m) -> div-mod-spec m n (div m n) O
divides-to-div-mod-spec = λ (n : nat) -> λ (m : nat) -> λ (posn : lt O n) -> λ (X-clearme : divides n m) -> match-divides n m lzero (λ (X-- : divides n m) -> div-mod-spec m n (div m n) O) (λ (q : nat) -> λ (eqm : eq lzero nat m (times n q)) -> div-mod-spec-intro m n (div m n) O posn (eq-ind-r lzero lzero nat (times n q) (λ (x : nat) -> λ (X-- : eq lzero nat x (times n q)) -> eq lzero nat x (plus (times (div x n) n) O)) (eq-ind-r lzero lzero nat (times q n) (λ (x : nat) -> λ (X-- : eq lzero nat x (times q n)) -> eq lzero nat x (plus (times (div x n) n) O)) (eq-ind-r lzero lzero nat q (λ (x : nat) -> λ (X-- : eq lzero nat x q) -> eq lzero nat (times q n) (plus (times x n) O)) (rewrite-r lzero lzero nat (times n q) (λ (X-- : nat) -> eq lzero nat X-- (plus (times q n) O)) (rewrite-l lzero lzero nat m (λ (X-- : nat) -> eq lzero nat X-- (plus (times q n) O)) (rewrite-r lzero lzero nat (times n q) (λ (X-- : nat) -> eq lzero nat m (plus X-- O)) (rewrite-l lzero lzero nat m (λ (X-- : nat) -> eq lzero nat m (plus X-- O)) (rewrite-l lzero lzero nat m (λ (X-- : nat) -> eq lzero nat m X--) (refl lzero nat m) (plus m O) (plus-n-O m)) (times n q) eqm) (times q n) (commutative-times q n)) (times n q) eqm) (times q n) (commutative-times q n)) (div (times q n) n) (div-times q n posn)) (times n q) (commutative-times n q)) m eqm)) X-clearme

div-mod-spec-to-divides : (n : nat) -> (m : nat) -> (q : nat) -> (X-- : div-mod-spec m n q O) -> divides n m
div-mod-spec-to-divides = λ (n : nat) -> λ (m : nat) -> λ (q : nat) -> λ (X-clearme : div-mod-spec m n q O) -> match-div-mod-spec m n q O lzero (λ (X-- : div-mod-spec m n q O) -> divides n m) (λ (posn : lt O n) -> λ (eqm : eq lzero nat m (plus (times q n) O)) -> quotient n m q (rewrite-r lzero lzero nat (times n q) (λ (X-- : nat) -> eq lzero nat X-- (times n q)) (refl lzero nat (times n q)) m (rewrite-r lzero lzero nat (plus O (times n q)) (λ (X-- : nat) -> eq lzero nat m X--) (rewrite-l lzero lzero nat (plus (times n q) O) (λ (X-- : nat) -> eq lzero nat m X--) (rewrite-l lzero lzero nat (times q n) (λ (X-- : nat) -> eq lzero nat m (plus X-- O)) eqm (times n q) (commutative-times q n)) (plus O (times n q)) (commutative-plus (times n q) O)) (times n q) (plus-O-n (times n q))))) X-clearme

divides-to-mod-O : (n : nat) -> (m : nat) -> (X-- : lt O n) -> (X--1 : divides n m) -> eq lzero nat (mod m n) O
divides-to-mod-O = λ (n : nat) -> λ (m : nat) -> λ (posn : lt O n) -> λ (divnm : divides n m) -> div-mod-spec-to-eq2 m n (div m n) (mod m n) (div m n) O (div-mod-spec-div-mod m n posn) (divides-to-div-mod-spec n m posn divnm)

mod-O-to-divides : (n : nat) -> (m : nat) -> (X-- : lt O n) -> (X--1 : eq lzero nat (mod m n) O) -> divides n m
mod-O-to-divides = λ (n : nat) -> λ (m : nat) -> λ (auto : lt O n) -> λ (auto' : eq lzero nat (mod m n) O) -> quotient n m (div m n) (rewrite-l lzero lzero nat (times n (div m n)) (λ (X-- : nat) -> eq lzero nat X-- (times n (div m n))) (refl lzero nat (times n (div m n))) m (rewrite-r lzero lzero nat (minus m O) (λ (X-- : nat) -> eq lzero nat (times n (div m n)) X--) (rewrite-l lzero lzero nat (mod m n) (λ (X-- : nat) -> eq lzero nat (times n (div m n)) (minus m X--)) (rewrite-l lzero lzero nat (times (div m n) n) (λ (X-- : nat) -> eq lzero nat X-- (minus m (mod m n))) (eq-times-div-minus-mod m n) (times n (div m n)) (commutative-times (div m n) n)) O auto') m (minus-n-O m)))

divides-n-O : (n : nat) -> divides n O
divides-n-O = λ (n : nat) -> quotient n O O (rewrite-r lzero lzero nat (times n O) (λ (X-- : nat) -> eq lzero nat X-- (times n O)) (refl lzero nat (times n O)) O (times-n-O n))

divides-n-n : (n : nat) -> divides n n
divides-n-n = λ (n : nat) -> reflexive-divides n

divides-SO-n : (n : nat) -> divides (S O) n
divides-SO-n = λ (n : nat) -> quotient (S O) n n (rewrite-r lzero lzero nat (times n (S O)) (λ (X-- : nat) -> eq lzero nat n X--) (rewrite-l lzero lzero nat n (λ (X-- : nat) -> eq lzero nat n X--) (refl lzero nat n) (times n (S O)) (times-n-1 n)) (times (S O) n) (commutative-times (S O) n))

divides-plus : (n : nat) -> (p : nat) -> (q : nat) -> (X-- : divides n p) -> (X--1 : divides n q) -> divides n (plus p q)
divides-plus = λ (n : nat) -> λ (p : nat) -> λ (q : nat) -> λ (X-clearme : divides n p) -> match-divides n p lzero (λ (X-- : divides n p) -> (X--1 : divides n q) -> divides n (plus p q)) (λ (d1 : nat) -> λ (H : eq lzero nat p (times n d1)) -> λ (X-clearme0 : divides n q) -> match-divides n q lzero (λ (X-- : divides n q) -> divides n (plus p q)) (λ (d2 : nat) -> λ (H1 : eq lzero nat q (times n d2)) -> quotient n (plus p q) (plus d1 d2) (eq-ind-r lzero lzero nat (times n d1) (λ (x : nat) -> λ (X-- : eq lzero nat x (times n d1)) -> eq lzero nat (plus x q) (times n (plus d1 d2))) (eq-ind-r lzero lzero nat (times n d2) (λ (x : nat) -> λ (X-- : eq lzero nat x (times n d2)) -> eq lzero nat (plus (times n d1) x) (times n (plus d1 d2))) (rewrite-l lzero lzero nat (times n (plus d1 d2)) (λ (X-- : nat) -> eq lzero nat X-- (times n (plus d1 d2))) (refl lzero nat (times n (plus d1 d2))) (plus (times n d1) (times n d2)) (distributive-times-plus n d1 d2)) q H1) p H)) X-clearme0) X-clearme

divides-minus : (n : nat) -> (p : nat) -> (q : nat) -> (X-- : divides n p) -> (X--1 : divides n q) -> divides n (minus p q)
divides-minus = λ (n : nat) -> λ (p : nat) -> λ (q : nat) -> λ (X-clearme : divides n p) -> match-divides n p lzero (λ (X-- : divides n p) -> (X--1 : divides n q) -> divides n (minus p q)) (λ (d1 : nat) -> λ (H : eq lzero nat p (times n d1)) -> λ (X-clearme0 : divides n q) -> match-divides n q lzero (λ (X-- : divides n q) -> divides n (minus p q)) (λ (d2 : nat) -> λ (H1 : eq lzero nat q (times n d2)) -> quotient n (minus p q) (minus d1 d2) (eq-ind-r lzero lzero nat (times n d1) (λ (x : nat) -> λ (X-- : eq lzero nat x (times n d1)) -> eq lzero nat (minus x q) (times n (minus d1 d2))) (eq-ind-r lzero lzero nat (times n d2) (λ (x : nat) -> λ (X-- : eq lzero nat x (times n d2)) -> eq lzero nat (minus (times n d1) x) (times n (minus d1 d2))) (rewrite-l lzero lzero nat (times n (minus d1 d2)) (λ (X-- : nat) -> eq lzero nat X-- (times n (minus d1 d2))) (refl lzero nat (times n (minus d1 d2))) (minus (times n d1) (times n d2)) (distributive-times-minus n d1 d2)) q H1) p H)) X-clearme0) X-clearme

divides-times : (n : nat) -> (m : nat) -> (p : nat) -> (q : nat) -> (X-- : divides n p) -> (X--1 : divides m q) -> divides (times n m) (times p q)
divides-times = λ (n : nat) -> λ (m : nat) -> λ (p : nat) -> λ (q : nat) -> λ (X-clearme : divides n p) -> match-divides n p lzero (λ (X-- : divides n p) -> (X--1 : divides m q) -> divides (times n m) (times p q)) (λ (d1 : nat) -> λ (H : eq lzero nat p (times n d1)) -> λ (X-clearme0 : divides m q) -> match-divides m q lzero (λ (X-- : divides m q) -> divides (times n m) (times p q)) (λ (d2 : nat) -> λ (H1 : eq lzero nat q (times m d2)) -> quotient (times n m) (times p q) (times d1 d2) (eq-ind-r lzero lzero nat (times n d1) (λ (x : nat) -> λ (X-- : eq lzero nat x (times n d1)) -> eq lzero nat (times x q) (times (times n m) (times d1 d2))) (eq-ind-r lzero lzero nat (times n (times d1 q)) (λ (x : nat) -> λ (X-- : eq lzero nat x (times n (times d1 q))) -> eq lzero nat x (times (times n m) (times d1 d2))) (eq-ind-r lzero lzero nat (times n (times m (times d1 d2))) (λ (x : nat) -> λ (X-- : eq lzero nat x (times n (times m (times d1 d2)))) -> eq lzero nat (times n (times d1 q)) x) (eq-f lzero lzero nat nat (times n) (times d1 q) (times m (times d1 d2)) (rewrite-l lzero lzero nat (times m (times d1 d2)) (λ (X-- : nat) -> eq lzero nat X-- (times m (times d1 d2))) (refl lzero nat (times m (times d1 d2))) (times d1 q) (rewrite-r lzero lzero nat (times m d2) (λ (X-- : nat) -> eq lzero nat (times m (times d1 d2)) (times d1 X--)) (times-times m d1 d2) q H1))) (times (times n m) (times d1 d2)) (associative-times n m (times d1 d2))) (times (times n d1) q) (associative-times n d1 q)) p H)) X-clearme0) X-clearme

transitive-divides : transitive lzero lzero nat divides
transitive-divides = λ (a : nat) -> λ (b : nat) -> λ (c : nat) -> λ (X-clearme : divides a b) -> match-divides a b lzero (λ (X-- : divides a b) -> (X--1 : divides b c) -> divides a c) (λ (d1 : nat) -> λ (H : eq lzero nat b (times a d1)) -> λ (X-clearme0 : divides b c) -> match-divides b c lzero (λ (X-- : divides b c) -> divides a c) (λ (d2 : nat) -> λ (H1 : eq lzero nat c (times b d2)) -> quotient a c (times d1 d2) (eq-ind-r lzero lzero nat (times b d2) (λ (x : nat) -> λ (X-- : eq lzero nat x (times b d2)) -> eq lzero nat x (times a (times d1 d2))) (eq-ind-r lzero lzero nat (times a d1) (λ (x : nat) -> λ (X-- : eq lzero nat x (times a d1)) -> eq lzero nat (times x d2) (times a (times d1 d2))) (rewrite-r lzero lzero nat (times a (times d1 d2)) (λ (X-- : nat) -> eq lzero nat X-- (times a (times d1 d2))) (refl lzero nat (times a (times d1 d2))) (times (times a d1) d2) (associative-times a d1 d2)) b H) c H1)) X-clearme0) X-clearme

eq-mod-to-divides : (n : nat) -> (m : nat) -> (q : nat) -> (X-- : lt O q) -> (X--1 : eq lzero nat (mod n q) (mod m q)) -> divides q (minus n m)
eq-mod-to-divides = λ (n : nat) -> λ (m : nat) -> λ (q : nat) -> λ (posq : lt O q) -> λ (eqmod : eq lzero nat (mod n q) (mod m q)) -> leb-elim lzero n m (λ (X-- : bool) -> divides q (minus n m)) (λ (nm : le n m) -> eq-coerc lzero (divides q O) (divides q (minus n m)) (divides-n-O q) (rewrite-r lzero (lsuc lzero) nat O (λ (X-- : nat) -> eq (lsuc lzero) (Set (lzero)) (divides q O) (divides q X--)) (refl (lsuc lzero) (Set (lzero)) (divides q O)) (minus n m) (sym-eq lzero nat O (minus n m) (eq-coerc lzero (eq lzero nat (minus O (minus m n)) (minus (plus O n) m)) (eq lzero nat O (minus n m)) (minus-le-minus-minus-comm m n O nm) (rewrite-l lzero (lsuc lzero) nat O (λ (X-- : nat) -> eq (lsuc lzero) (Set (lzero)) (eq lzero nat X-- (minus (plus O n) m)) (eq lzero nat O (minus n m))) (rewrite-l lzero (lsuc lzero) nat n (λ (X-- : nat) -> eq (lsuc lzero) (Set (lzero)) (eq lzero nat O (minus X-- m)) (eq lzero nat O (minus n m))) (refl (lsuc lzero) (Set (lzero)) (eq lzero nat O (minus n m))) (plus O n) (plus-O-n n)) (minus O (minus m n)) (minus-O-n (minus m n))))))) (λ (nm : Not lzero (le n m)) -> quotient q (minus n m) (minus (div n q) (div m q)) (eq-ind-r lzero lzero nat (minus (times q (div n q)) (times q (div m q))) (λ (x : nat) -> λ (X-- : eq lzero nat x (minus (times q (div n q)) (times q (div m q)))) -> eq lzero nat (minus n m) x) (eq-ind-r lzero lzero nat (times (div n q) q) (λ (x : nat) -> λ (X-- : eq lzero nat x (times (div n q) q)) -> eq lzero nat (minus n m) (minus x (times q (div m q)))) (eq-ind-r lzero lzero nat (times (div m q) q) (λ (x : nat) -> λ (X-- : eq lzero nat x (times (div m q) q)) -> eq lzero nat (minus n m) (minus (times (div n q) q) x)) (eq-ind-r lzero lzero nat (minus n (mod n q)) (λ (x : nat) -> λ (X-- : eq lzero nat x (minus n (mod n q))) -> eq lzero nat (minus n m) (minus x (times (div m q) q))) (eq-ind-r lzero lzero nat (minus n (plus (mod n q) (times (div m q) q))) (λ (x : nat) -> λ (X-- : eq lzero nat x (minus n (plus (mod n q) (times (div m q) q)))) -> eq lzero nat (minus n m) x) (eq-ind-r lzero lzero nat (mod m q) (λ (x : nat) -> λ (X-- : eq lzero nat x (mod m q)) -> eq lzero nat (minus n m) (minus n (plus x (times (div m q) q)))) (eq-ind-r lzero lzero nat (plus (times (div m q) q) (mod m q)) (λ (x : nat) -> λ (X-- : eq lzero nat x (plus (times (div m q) q) (mod m q))) -> eq lzero nat (minus n m) (minus n x)) (eq-ind lzero lzero nat m (λ (x-1 : nat) -> λ (X-x-2 : eq lzero nat m x-1) -> eq lzero nat (minus n m) (minus n x-1)) (refl lzero nat (minus n m)) (plus (times (div m q) q) (mod m q)) (div-mod m q)) (plus (mod m q) (times (div m q) q)) (commutative-plus (mod m q) (times (div m q) q))) (mod n q) eqmod) (minus (minus n (mod n q)) (times (div m q) q)) (minus-plus n (mod n q) (times (div m q) q))) (times (div n q) q) (rewrite-r lzero lzero nat (times q (div n q)) (λ (X-- : nat) -> eq lzero nat X-- (minus n (mod n q))) (rewrite-l lzero lzero nat (times q (div n q)) (λ (X-- : nat) -> eq lzero nat (times q (div n q)) X--) (refl lzero nat (times q (div n q))) (minus n (mod n q)) (rewrite-l lzero lzero nat (times (div n q) q) (λ (X-- : nat) -> eq lzero nat X-- (minus n (mod n q))) (eq-times-div-minus-mod n q) (times q (div n q)) (commutative-times (div n q) q))) (times (div n q) q) (commutative-times (div n q) q))) (times q (div m q)) (commutative-times q (div m q))) (times q (div n q)) (commutative-times q (div n q))) (times q (minus (div n q) (div m q))) (distributive-times-minus q (div n q) (div m q))))

let-clause-1531 : (n : nat) -> (m : nat) -> (posm : lt O m) -> (X-clearme : divides n m) -> (d : nat) -> (eqm : eq lzero nat m (times n O)) -> eq lzero nat m O
let-clause-1531 = λ (n : nat) -> λ (m : nat) -> λ (posm : lt O m) -> λ (X-clearme : divides n m) -> λ (d : nat) -> λ (eqm : eq lzero nat m (times n O)) -> rewrite-r lzero lzero nat (times n O) (λ (X-- : nat) -> eq lzero nat m X--) eqm O (times-n-O n)

let-clause-15311 : (n : nat) -> (m : nat) -> (posm : lt O m) -> (X-clearme : divides n m) -> (d : nat) -> (p : nat) -> (eqm : eq lzero nat m (times n (S p))) -> eq lzero nat m (plus n (times n p))
let-clause-15311 = λ (n : nat) -> λ (m : nat) -> λ (posm : lt O m) -> λ (X-clearme : divides n m) -> λ (d : nat) -> λ (p : nat) -> λ (eqm : eq lzero nat m (times n (S p))) -> rewrite-r lzero lzero nat (times n (S p)) (λ (X-- : nat) -> eq lzero nat m X--) eqm (plus n (times n p)) (times-n-Sm n p)

divides-to-le : (n : nat) -> (m : nat) -> (X-- : lt O m) -> (X--1 : divides n m) -> le n m
divides-to-le = λ (n : nat) -> λ (m : nat) -> λ (posm : lt O m) -> λ (X-clearme : divides n m) -> match-divides n m lzero (λ (X-- : divides n m) -> le n m) (λ (d : nat) -> match-nat lzero (λ (X-- : nat) -> (X--1 : eq lzero nat m (times n X--)) -> le n m) (λ (eqm : eq lzero nat m (times n O)) -> False-ind lzero lzero (λ (X-x-66 : False lzero) -> le n m) (absurd lzero (le (S m) O) (eq-coerc lzero (le (S O) m) (le (S m) O) posm (rewrite-l lzero (lsuc lzero) nat m (λ (X-- : nat) -> eq (lsuc lzero) (Set (lzero)) (le (S X--) m) (le (S m) O)) (rewrite-l lzero (lsuc lzero) nat m (λ (X-- : nat) -> eq (lsuc lzero) (Set (lzero)) (le (S m) m) (le (S m) X--)) (refl (lsuc lzero) (Set (lzero)) (le (S m) m)) O (let-clause-1531 n m posm X-clearme d eqm)) O (let-clause-1531 n m posm X-clearme d eqm))) (not-le-Sn-O m))) (λ (p : nat) -> λ (eqm : eq lzero nat m (times n (S p))) -> eq-ind-r lzero lzero nat (times n (S p)) (λ (x : nat) -> λ (X-- : eq lzero nat x (times n (S p))) -> le n x) (eq-coerc lzero (le n (plus n (times n p))) (le n (times n (S p))) (le-plus-n-r (times n p) n) (rewrite-l lzero (lsuc lzero) nat (plus n (times n p)) (λ (X-- : nat) -> eq (lsuc lzero) (Set (lzero)) (le n (plus n (times n p))) (le n X--)) (rewrite-l lzero (lsuc lzero) nat m (λ (X-- : nat) -> eq (lsuc lzero) (Set (lzero)) (le n (plus n (times n p))) (le n X--)) (rewrite-l lzero (lsuc lzero) nat m (λ (X-- : nat) -> eq (lsuc lzero) (Set (lzero)) (le n X--) (le n m)) (refl (lsuc lzero) (Set (lzero)) (le n m)) (plus n (times n p)) (let-clause-15311 n m posm X-clearme d p eqm)) (plus n (times n p)) (let-clause-15311 n m posm X-clearme d p eqm)) (times n (S p)) (times-n-Sm n p))) m eqm) d) X-clearme

antisymmetric-divides : (n : nat) -> (m : nat) -> (X-- : divides n m) -> (X--1 : divides m n) -> eq lzero nat n m
antisymmetric-divides = λ (n : nat) -> λ (m : nat) -> λ (divnm : divides n m) -> λ (divmn : divides m n) -> match-Or lzero lzero (lt O n) (eq lzero nat O n) lzero (λ (X-- : Or lzero lzero (lt O n) (eq lzero nat O n)) -> eq lzero nat n m) (λ (Hn : lt O n) -> match-Or lzero lzero (lt O m) (eq lzero nat O m) lzero (λ (X-- : Or lzero lzero (lt O m) (eq lzero nat O m)) -> eq lzero nat n m) (λ (Hm : lt O m) -> le-to-le-to-eq n m (divides-to-le n m Hm divnm) (divides-to-le m n Hn divmn)) (λ (Hm : eq lzero nat O m) -> eq-ind lzero lzero nat O (λ (x-1 : nat) -> λ (X-x-2 : eq lzero nat O x-1) -> eq lzero nat n x-1) (match-divides m n lzero (λ (X-- : divides m n) -> eq lzero nat n O) (λ (q : nat) -> λ (auto : eq lzero nat n (times m q)) -> rewrite-r lzero lzero nat n (λ (X-- : nat) -> eq lzero nat n X--) (refl lzero nat n) O (rewrite-r lzero lzero nat m (λ (X-- : nat) -> eq lzero nat O X--) Hm n (rewrite-r lzero lzero nat (times m q) (λ (X-- : nat) -> eq lzero nat n X--) auto m (rewrite-l lzero lzero nat O (λ (X-- : nat) -> eq lzero nat m (times X-- q)) (rewrite-l lzero lzero nat O (λ (X-- : nat) -> eq lzero nat X-- (times O q)) (times-O-n q) m Hm) m Hm)))) divmn) m Hm) (le-to-or-lt-eq O m (le-O-n m))) (λ (Hn : eq lzero nat O n) -> eq-ind lzero lzero nat O (λ (x-1 : nat) -> λ (X-x-2 : eq lzero nat O x-1) -> eq lzero nat x-1 m) (match-divides n m lzero (λ (X-- : divides n m) -> eq lzero nat O m) (λ (q : nat) -> λ (auto : eq lzero nat m (times n q)) -> rewrite-r lzero lzero nat n (λ (X-- : nat) -> eq lzero nat X-- m) (rewrite-r lzero lzero nat n (λ (X-- : nat) -> eq lzero nat n X--) (refl lzero nat n) m (rewrite-r lzero lzero nat (times n q) (λ (X-- : nat) -> eq lzero nat m X--) auto n (rewrite-l lzero lzero nat O (λ (X-- : nat) -> eq lzero nat n (times X-- q)) (rewrite-l lzero lzero nat O (λ (X-- : nat) -> eq lzero nat X-- (times O q)) (times-O-n q) n Hn) n Hn))) O Hn) divnm) n Hn) (le-to-or-lt-eq O n (le-O-n n))

divides-to-lt-O : (n : nat) -> (m : nat) -> (X-- : lt O m) -> (X--1 : divides n m) -> lt O n
divides-to-lt-O = λ (n : nat) -> λ (m : nat) -> λ (posm : lt O m) -> match-Or lzero lzero (lt O n) (eq lzero nat O n) lzero (λ (X-- : Or lzero lzero (lt O n) (eq lzero nat O n)) -> (X--1 : divides n m) -> lt O n) (λ (auto : lt O n) -> λ (auto' : divides n m) -> auto) (λ (eqn0 : eq lzero nat O n) -> λ (X-clearme : divides n m) -> match-divides n m lzero (λ (X-- : divides n m) -> lt O n) (λ (d : nat) -> eq-ind lzero lzero nat O (λ (x-1 : nat) -> λ (X-x-2 : eq lzero nat O x-1) -> (X-- : eq lzero nat m (times x-1 d)) -> lt O x-1) (λ (eqm : eq lzero nat m (times O d)) -> False-ind lzero lzero (λ (X-x-66 : False lzero) -> lt O O) (absurd lzero (lt O m) posm (le-to-not-lt m O (eq-ind-r lzero lzero nat (times O d) (λ (x : nat) -> λ (X-- : eq lzero nat x (times O d)) -> le x O) (le-n (times O d)) m eqm)))) n eqn0) X-clearme) (le-to-or-lt-eq O n (le-O-n n))

or-div-mod1 : (n : nat) -> (q : nat) -> (X-- : lt O q) -> Or lzero lzero (And lzero lzero (divides q (S n)) (eq lzero nat (S n) (times (S (div n q)) q))) (And lzero lzero (Not lzero (divides q (S n))) (eq lzero nat (S n) (plus (times (div n q) q) (S (mod n q)))))
or-div-mod1 = λ (n : nat) -> λ (q : nat) -> λ (posq : lt O q) -> match-Or lzero lzero (And lzero lzero (eq lzero nat (S (mod n q)) q) (eq lzero nat (S n) (times (S (div n q)) q))) (And lzero lzero (lt (S (mod n q)) q) (eq lzero nat (S n) (plus (times (div n q) q) (S (mod n q))))) lzero (λ (X-- : Or lzero lzero (And lzero lzero (eq lzero nat (S (mod n q)) q) (eq lzero nat (S n) (times (S (div n q)) q))) (And lzero lzero (lt (S (mod n q)) q) (eq lzero nat (S n) (plus (times (div n q) q) (S (mod n q)))))) -> Or lzero lzero (And lzero lzero (divides q (S n)) (eq lzero nat (S n) (times (S (div n q)) q))) (And lzero lzero (Not lzero (divides q (S n))) (eq lzero nat (S n) (plus (times (div n q) q) (S (mod n q)))))) (λ (X-clearme : And lzero lzero (eq lzero nat (S (mod n q)) q) (eq lzero nat (S n) (times (S (div n q)) q))) -> match-And lzero lzero (eq lzero nat (S (mod n q)) q) (eq lzero nat (S n) (times (S (div n q)) q)) lzero (λ (X-- : And lzero lzero (eq lzero nat (S (mod n q)) q) (eq lzero nat (S n) (times (S (div n q)) q))) -> Or lzero lzero (And lzero lzero (divides q (S n)) (eq lzero nat (S n) (times (S (div n q)) q))) (And lzero lzero (Not lzero (divides q (S n))) (eq lzero nat (S n) (plus (times (div n q) q) (S (mod n q)))))) (λ (H1 : eq lzero nat (S (mod n q)) q) -> λ (H2 : eq lzero nat (S n) (times (S (div n q)) q)) -> or-introl lzero lzero (And lzero lzero (divides q (S n)) (eq lzero nat (S n) (times (S (div n q)) q))) (And lzero lzero (Not lzero (divides q (S n))) (eq lzero nat (S n) (plus (times (div n q) q) (S (mod n q))))) (conj lzero lzero (divides q (S n)) (eq lzero nat (S n) (times (S (div n q)) q)) (eq-coerc lzero (divides (times q (S O)) (times q (S (div n q)))) (divides q (S n)) (divides-times q (S O) q (S (div n q)) (divides-n-n q) (divides-SO-n (S (div n q)))) (rewrite-r lzero (lsuc lzero) nat (plus q (times q (div n q))) (λ (X-- : nat) -> eq (lsuc lzero) (Set (lzero)) (divides (times q (S O)) (times q (S (div n q)))) (divides q X--)) (rewrite-l lzero (lsuc lzero) nat q (λ (X-- : nat) -> eq (lsuc lzero) (Set (lzero)) (divides X-- (times q (S (div n q)))) (divides q (plus q (times q (div n q))))) (rewrite-l lzero (lsuc lzero) nat (plus q (times q (div n q))) (λ (X-- : nat) -> eq (lsuc lzero) (Set (lzero)) (divides q X--) (divides q (plus q (times q (div n q))))) (refl (lsuc lzero) (Set (lzero)) (divides q (plus q (times q (div n q))))) (times q (S (div n q))) (times-n-Sm q (div n q))) (times q (S O)) (times-n-1 q)) (S n) (rewrite-r lzero lzero nat (times q (S (div n q))) (λ (X-- : nat) -> eq lzero nat (S n) X--) (rewrite-l lzero lzero nat (times (S (div n q)) q) (λ (X-- : nat) -> eq lzero nat (S n) X--) H2 (times q (S (div n q))) (commutative-times (S (div n q)) q)) (plus q (times q (div n q))) (times-n-Sm q (div n q))))) (rewrite-r lzero lzero nat (plus q (times q (div n q))) (λ (X-- : nat) -> eq lzero nat X-- (times (S (div n q)) q)) (rewrite-r lzero lzero nat (times q (S (div n q))) (λ (X-- : nat) -> eq lzero nat (plus q (times q (div n q))) X--) (rewrite-l lzero lzero nat (plus q (times q (div n q))) (λ (X-- : nat) -> eq lzero nat (plus q (times q (div n q))) X--) (refl lzero nat (plus q (times q (div n q)))) (times q (S (div n q))) (times-n-Sm q (div n q))) (times (S (div n q)) q) (commutative-times (S (div n q)) q)) (S n) (rewrite-r lzero lzero nat (times q (S (div n q))) (λ (X-- : nat) -> eq lzero nat (S n) X--) (rewrite-l lzero lzero nat (times (S (div n q)) q) (λ (X-- : nat) -> eq lzero nat (S n) X--) H2 (times q (S (div n q))) (commutative-times (S (div n q)) q)) (plus q (times q (div n q))) (times-n-Sm q (div n q)))))) X-clearme) (λ (X-clearme : And lzero lzero (lt (S (mod n q)) q) (eq lzero nat (S n) (plus (times (div n q) q) (S (mod n q))))) -> match-And lzero lzero (lt (S (mod n q)) q) (eq lzero nat (S n) (plus (times (div n q) q) (S (mod n q)))) lzero (λ (X-- : And lzero lzero (lt (S (mod n q)) q) (eq lzero nat (S n) (plus (times (div n q) q) (S (mod n q))))) -> Or lzero lzero (And lzero lzero (divides q (S n)) (eq lzero nat (S n) (times (S (div n q)) q))) (And lzero lzero (Not lzero (divides q (S n))) (eq lzero nat (S n) (plus (times (div n q) q) (S (mod n q)))))) (λ (H1 : lt (S (mod n q)) q) -> λ (H2 : eq lzero nat (S n) (plus (times (div n q) q) (S (mod n q)))) -> or-intror lzero lzero (And lzero lzero (divides q (S n)) (eq lzero nat (S n) (times (S (div n q)) q))) (And lzero lzero (Not lzero (divides q (S n))) (eq lzero nat (S n) (plus (times (div n q) q) (S (mod n q))))) (conj lzero lzero (Not lzero (divides q (S n))) (eq lzero nat (S n) (plus (times (div n q) q) (S (mod n q)))) (not-to-not lzero (divides q (S n)) (eq lzero nat (mod (S n) q) O) (divides-to-mod-O q (S n) posq) (eq-ind-r lzero lzero nat (S (mod n q)) (λ (x : nat) -> λ (X-- : eq lzero nat x (S (mod n q))) -> Not lzero (eq lzero nat x O)) (nmk lzero (eq lzero nat (S (mod n q)) O) (λ (auto : eq lzero nat (S (mod n q)) O) -> absurd lzero (eq lzero nat O (S (mod n q))) (rewrite-l lzero lzero nat (S (mod n q)) (λ (X-- : nat) -> eq lzero nat X-- (S (mod n q))) (refl lzero nat (S (mod n q))) O auto) (not-eq-O-S (mod n q)))) (mod (S n) q) (div-mod-spec-to-eq2 (S n) q (div (S n) q) (mod (S n) q) (div n q) (S (mod n q)) (div-mod-spec-div-mod (S n) q posq) (div-mod-spec-intro (S n) q (div n q) (S (mod n q)) H1 (rewrite-r lzero lzero nat (times q (div n q)) (λ (X-- : nat) -> eq lzero nat (S n) (plus X-- (S (mod n q)))) (rewrite-l lzero lzero nat (S n) (λ (X-- : nat) -> eq lzero nat (S n) X--) (refl lzero nat (S n)) (plus (times q (div n q)) (S (mod n q))) (rewrite-l lzero lzero nat (times (div n q) q) (λ (X-- : nat) -> eq lzero nat (S n) (plus X-- (S (mod n q)))) H2 (times q (div n q)) (commutative-times (div n q) q))) (times (div n q) q) (commutative-times (div n q) q)))))) (rewrite-r lzero lzero nat (times q (div n q)) (λ (X-- : nat) -> eq lzero nat (S n) (plus X-- (S (mod n q)))) (rewrite-l lzero lzero nat (S n) (λ (X-- : nat) -> eq lzero nat (S n) X--) (refl lzero nat (S n)) (plus (times q (div n q)) (S (mod n q))) (rewrite-l lzero lzero nat (times (div n q) q) (λ (X-- : nat) -> eq lzero nat (S n) (plus X-- (S (mod n q)))) H2 (times q (div n q)) (commutative-times (div n q) q))) (times (div n q) q) (commutative-times (div n q) q)))) X-clearme) (or-div-mod n q posq)

let-clause-1532 : (n : nat) -> (m : nat) -> (divnm : divides n m) -> (H : eq lzero nat O n) -> (d : nat) -> (auto : eq lzero nat m (times O d)) -> eq lzero nat m O
let-clause-1532 = λ (n : nat) -> λ (m : nat) -> λ (divnm : divides n m) -> λ (H : eq lzero nat O n) -> λ (d : nat) -> λ (auto : eq lzero nat m (times O d)) -> rewrite-r lzero lzero nat (times d O) (λ (X-- : nat) -> eq lzero nat m X--) (rewrite-l lzero lzero nat (times O d) (λ (X-- : nat) -> eq lzero nat m X--) auto (times d O) (commutative-times O d)) O (times-n-O d)

let-clause-1559 : (n : nat) -> (m : nat) -> (divnm : divides n m) -> (H : eq lzero nat O n) -> (d : nat) -> (auto : eq lzero nat m (times O d)) -> eq lzero nat m n
let-clause-1559 = λ (n : nat) -> λ (m : nat) -> λ (divnm : divides n m) -> λ (H : eq lzero nat O n) -> λ (d : nat) -> λ (auto : eq lzero nat m (times O d)) -> rewrite-r lzero lzero nat O (λ (X-- : nat) -> eq lzero nat X-- n) H m (let-clause-1532 n m divnm H d auto)

let-clause-1560 : (n : nat) -> (m : nat) -> (divnm : divides n m) -> (H : eq lzero nat O n) -> (d : nat) -> (auto : eq lzero nat m (times O d)) -> eq lzero nat n O
let-clause-1560 = λ (n : nat) -> λ (m : nat) -> λ (divnm : divides n m) -> λ (H : eq lzero nat O n) -> λ (d : nat) -> λ (auto : eq lzero nat m (times O d)) -> rewrite-l lzero lzero nat m (λ (X-- : nat) -> eq lzero nat X-- O) (let-clause-1532 n m divnm H d auto) n (let-clause-1559 n m divnm H d auto)

divides-to-div : (n : nat) -> (m : nat) -> (X-- : divides n m) -> eq lzero nat (times (div m n) n) m
divides-to-div = λ (n : nat) -> λ (m : nat) -> λ (divnm : divides n m) -> match-Or lzero lzero (lt O n) (eq lzero nat O n) lzero (λ (X-- : Or lzero lzero (lt O n) (eq lzero nat O n)) -> eq lzero nat (times (div m n) n) m) (λ (H : lt O n) -> eq-ind-r lzero lzero nat (plus (times (div m n) n) O) (λ (x : nat) -> λ (X-- : eq lzero nat x (plus (times (div m n) n) O)) -> eq lzero nat x m) (eq-ind lzero lzero nat (mod m n) (λ (x-1 : nat) -> λ (X-x-2 : eq lzero nat (mod m n) x-1) -> eq lzero nat (plus (times (div m n) n) x-1) m) (rewrite-r lzero lzero nat (times n (div m n)) (λ (X-- : nat) -> eq lzero nat (plus X-- (mod m n)) m) (rewrite-r lzero lzero nat (plus (mod m n) (times n (div m n))) (λ (X-- : nat) -> eq lzero nat X-- m) (rewrite-l lzero lzero nat m (λ (X-- : nat) -> eq lzero nat X-- m) (refl lzero nat m) (plus (mod m n) (times n (div m n))) (rewrite-l lzero lzero nat (plus (times n (div m n)) (mod m n)) (λ (X-- : nat) -> eq lzero nat m X--) (rewrite-l lzero lzero nat (times (div m n) n) (λ (X-- : nat) -> eq lzero nat m (plus X-- (mod m n))) (div-mod m n) (times n (div m n)) (commutative-times (div m n) n)) (plus (mod m n) (times n (div m n))) (commutative-plus (times n (div m n)) (mod m n)))) (plus (times n (div m n)) (mod m n)) (commutative-plus (times n (div m n)) (mod m n))) (times (div m n) n) (commutative-times (div m n) n)) O (divides-to-mod-O n m H divnm)) (times (div m n) n) (plus-n-O (times (div m n) n))) (λ (H : eq lzero nat O n) -> match-divides n m lzero (λ (X-- : divides n m) -> eq lzero nat (times (div m n) n) m) (λ (d : nat) -> eq-ind lzero lzero nat O (λ (x-1 : nat) -> λ (X-x-2 : eq lzero nat O x-1) -> (X-- : eq lzero nat m (times x-1 d)) -> eq lzero nat (times (div m x-1) x-1) m) (λ (auto : eq lzero nat m (times O d)) -> rewrite-r lzero lzero nat n (λ (X-- : nat) -> eq lzero nat (times (div X-- O) O) m) (rewrite-l lzero lzero nat n (λ (X-- : nat) -> eq lzero nat (times (div n X--) O) m) (rewrite-l lzero lzero nat n (λ (X-- : nat) -> eq lzero nat (times (div n n) X--) m) (rewrite-r lzero lzero nat (times n (div n n)) (λ (X-- : nat) -> eq lzero nat X-- m) (rewrite-l lzero lzero nat n (λ (X-- : nat) -> eq lzero nat X-- m) (rewrite-r lzero lzero nat n (λ (X-- : nat) -> eq lzero nat n X--) (refl lzero nat n) m (let-clause-1559 n m divnm H d auto)) (times n (div n n)) (rewrite-l lzero lzero nat m (λ (X-- : nat) -> eq lzero nat n (times X-- (div n n))) (rewrite-l lzero lzero nat m (λ (X-- : nat) -> eq lzero nat X-- (times m (div n n))) (rewrite-r lzero lzero nat O (λ (X-- : nat) -> eq lzero nat m (times X-- (div n n))) (rewrite-r lzero lzero nat O (λ (X-- : nat) -> eq lzero nat X-- (times O (div n n))) (times-O-n (div n n)) m (let-clause-1532 n m divnm H d auto)) m (let-clause-1532 n m divnm H d auto)) n (let-clause-1559 n m divnm H d auto)) n (let-clause-1559 n m divnm H d auto))) (times (div n n) n) (commutative-times (div n n) n)) O (let-clause-1560 n m divnm H d auto)) O (let-clause-1560 n m divnm H d auto)) m (let-clause-1559 n m divnm H d auto)) n H) divnm) (le-to-or-lt-eq O n (le-O-n n))

divides-div : (d : nat) -> (n : nat) -> (X-- : divides d n) -> divides (div n d) n
divides-div = λ (d : nat) -> λ (n : nat) -> λ (divdn : divides d n) -> quotient (div n d) n d (sym-eq lzero nat (times (div n d) d) n (divides-to-div d n divdn))

div-div : (n : nat) -> (d : nat) -> (X-- : lt O n) -> (X--1 : divides d n) -> eq lzero nat (div n (div n d)) d
div-div = λ (n : nat) -> λ (d : nat) -> λ (posn : lt O n) -> λ (divdn : divides d n) -> injective-times-l (div n d) (lt-times-n-to-lt-l d O (div n d) (eq-ind-r lzero lzero nat n (λ (x : nat) -> λ (X-- : eq lzero nat x n) -> lt (times O d) x) posn (times (div n d) d) (divides-to-div d n divdn))) (div n (div n d)) d (eq-ind-r lzero lzero nat n (λ (x : nat) -> λ (X-- : eq lzero nat x n) -> eq lzero nat x (times d (div n d))) (eq-ind-r lzero lzero nat (times (div n d) d) (λ (x : nat) -> λ (X-- : eq lzero nat x (times (div n d) d)) -> eq lzero nat n x) (eq-ind-r lzero lzero nat n (λ (x : nat) -> λ (X-- : eq lzero nat x n) -> eq lzero nat n x) (refl lzero nat n) (times (div n d) d) (divides-to-div d n divdn)) (times d (div n d)) (commutative-times d (div n d))) (times (div n (div n d)) (div n d)) (divides-to-div (div n d) n (quotient (div n d) n d (sym-eq lzero nat (times (div n d) d) n (divides-to-div d n divdn)))))

times-div : (a : nat) -> (b : nat) -> (c : nat) -> (X-- : lt O b) -> (X--1 : divides c b) -> eq lzero nat (times a (div b c)) (div (times a b) c)
times-div = λ (a : nat) -> λ (b : nat) -> λ (c : nat) -> λ (posb : lt O b) -> λ (divcb : divides c b) -> match-divides c b lzero (λ (X-- : divides c b) -> eq lzero nat (times a (div b c)) (div (times a b) c)) (λ (d : nat) -> λ (eqb-v : eq lzero nat b (times c d)) -> eq-ind-r lzero lzero nat (times c d) (λ (x : nat) -> λ (X-- : eq lzero nat x (times c d)) -> eq lzero nat (times a (div x c)) (div (times a x) c)) (eq-ind-r lzero lzero nat (times d c) (λ (x : nat) -> λ (X-- : eq lzero nat x (times d c)) -> eq lzero nat (times a (div x c)) (div (times a x) c)) (eq-ind-r lzero lzero nat d (λ (x : nat) -> λ (X-- : eq lzero nat x d) -> eq lzero nat (times a x) (div (times a (times d c)) c)) (eq-ind lzero lzero nat (times (times a d) c) (λ (x-1 : nat) -> λ (X-x-2 : eq lzero nat (times (times a d) c) x-1) -> eq lzero nat (times a d) (div x-1 c)) (eq-ind-r lzero lzero nat (times a d) (λ (x : nat) -> λ (X-- : eq lzero nat x (times a d)) -> eq lzero nat (times a d) x) (refl lzero nat (times a d)) (div (times (times a d) c) c) (div-times (times a d) c (divides-to-lt-O c b posb divcb))) (times a (times d c)) (associative-times a d c)) (div (times d c) c) (div-times d c (divides-to-lt-O c b posb divcb))) (times c d) (commutative-times c d)) b eqb-v) divcb

plus-div : (n : nat) -> (m : nat) -> (d : nat) -> (X-- : lt O d) -> (X--1 : divides d n) -> (X--2 : divides d m) -> eq lzero nat (div (plus n m) d) (plus (div n d) (div m d))
plus-div = λ (n : nat) -> λ (m : nat) -> λ (d : nat) -> λ (posd : lt O d) -> λ (divdn : divides d n) -> λ (divdm : divides d m) -> match-divides d n lzero (λ (X-- : divides d n) -> eq lzero nat (div (plus n m) d) (plus (div n d) (div m d))) (λ (a : nat) -> λ (eqn : eq lzero nat n (times d a)) -> match-divides d m lzero (λ (X-- : divides d m) -> eq lzero nat (div (plus n m) d) (plus (div n d) (div m d))) (λ (b : nat) -> λ (eqm : eq lzero nat m (times d b)) -> eq-ind-r lzero lzero nat (times d a) (λ (x : nat) -> λ (X-- : eq lzero nat x (times d a)) -> eq lzero nat (div (plus x m) d) (plus (div x d) (div m d))) (eq-ind-r lzero lzero nat (times d b) (λ (x : nat) -> λ (X-- : eq lzero nat x (times d b)) -> eq lzero nat (div (plus (times d a) x) d) (plus (div (times d a) d) (div x d))) (eq-ind lzero lzero nat (times d (plus a b)) (λ (x-1 : nat) -> λ (X-x-2 : eq lzero nat (times d (plus a b)) x-1) -> eq lzero nat (div x-1 d) (plus (div (times d a) d) (div (times d b) d))) (eq-ind-r lzero lzero nat (times (plus a b) d) (λ (x : nat) -> λ (X-- : eq lzero nat x (times (plus a b) d)) -> eq lzero nat (div x d) (plus (div (times d a) d) (div (times d b) d))) (eq-ind-r lzero lzero nat (plus a b) (λ (x : nat) -> λ (X-- : eq lzero nat x (plus a b)) -> eq lzero nat x (plus (div (times d a) d) (div (times d b) d))) (eq-ind-r lzero lzero nat (times a d) (λ (x : nat) -> λ (X-- : eq lzero nat x (times a d)) -> eq lzero nat (plus a b) (plus (div x d) (div (times d b) d))) (eq-ind-r lzero lzero nat a (λ (x : nat) -> λ (X-- : eq lzero nat x a) -> eq lzero nat (plus a b) (plus x (div (times d b) d))) (eq-ind-r lzero lzero nat (times b d) (λ (x : nat) -> λ (X-- : eq lzero nat x (times b d)) -> eq lzero nat (plus a b) (plus a (div x d))) (eq-ind-r lzero lzero nat b (λ (x : nat) -> λ (X-- : eq lzero nat x b) -> eq lzero nat (plus a b) (plus a x)) (refl lzero nat (plus a b)) (div (times b d) d) (div-times b d posd)) (times d b) (commutative-times d b)) (div (times a d) d) (div-times a d posd)) (times d a) (commutative-times d a)) (div (times (plus a b) d) d) (div-times (plus a b) d posd)) (times d (plus a b)) (commutative-times d (plus a b))) (plus (times d a) (times d b)) (distributive-times-plus d a b)) m eqm) n eqn) divdm) divdn

dividesb : (X-- : nat) -> (X--1 : nat) -> bool
dividesb = λ (n : nat) -> λ (m : nat) -> eqb (mod m n) O

dividesb-true-to-divides : (n : nat) -> (m : nat) -> (X-- : eq lzero bool (dividesb n m) true) -> divides n m
dividesb-true-to-divides = λ (n : nat) -> λ (m : nat) -> match-Or lzero lzero (lt O n) (eq lzero nat O n) lzero (λ (X-- : Or lzero lzero (lt O n) (eq lzero nat O n)) -> (X--1 : eq lzero bool (dividesb n m) true) -> divides n m) (λ (posn : lt O n) -> λ (divbnm : eq lzero bool (dividesb n m) true) -> mod-O-to-divides n m posn (eqb-true-to-eq (mod m n) O divbnm)) (λ (eqnO : eq lzero nat O n) -> eq-ind lzero lzero nat O (λ (x-1 : nat) -> λ (X-x-2 : eq lzero nat O x-1) -> (X-- : eq lzero bool (dividesb x-1 m) true) -> divides x-1 m) (λ (eqbmO : eq lzero bool (eqb m O) true) -> eq-ind-r lzero lzero nat O (λ (x : nat) -> λ (X-- : eq lzero nat x O) -> divides O x) (divides-n-n O) m (eqb-true-to-eq m O eqbmO)) n eqnO) (le-to-or-lt-eq O n (le-O-n n))

dividesb-false-to-not-divides : (n : nat) -> (m : nat) -> (X-- : eq lzero bool (dividesb n m) false) -> Not lzero (divides n m)
dividesb-false-to-not-divides = λ (n : nat) -> λ (m : nat) -> match-Or lzero lzero (lt O n) (eq lzero nat O n) lzero (λ (X-- : Or lzero lzero (lt O n) (eq lzero nat O n)) -> (X--1 : eq lzero bool (dividesb n m) false) -> Not lzero (divides n m)) (λ (posn : lt O n) -> λ (ndivbnm : eq lzero bool (dividesb n m) false) -> not-to-not lzero (divides n m) (eq lzero nat (mod m n) O) (divides-to-mod-O n m posn) (eqb-false-to-not-eq (mod m n) O ndivbnm)) (λ (eqnO : eq lzero nat O n) -> eq-ind lzero lzero nat O (λ (x-1 : nat) -> λ (X-x-2 : eq lzero nat O x-1) -> (X-- : eq lzero bool (dividesb x-1 m) false) -> Not lzero (divides x-1 m)) (nat-case lzero m (λ (X-- : nat) -> (X--1 : eq lzero bool (eqb X-- O) false) -> Not lzero (divides O X--)) (λ (auto : eq lzero nat m O) -> λ (auto' : eq lzero bool true false) -> not-to-not lzero (divides O O) (eq lzero bool true false) (λ (auto'' : divides O O) -> rewrite-l lzero lzero bool true (λ (X-- : bool) -> eq lzero bool true X--) (refl lzero bool true) false auto') not-eq-true-false) (λ (a : nat) -> λ (X-- : eq lzero nat m (S a)) -> λ (X-0 : eq lzero bool (eqb (S a) O) false) -> nmk lzero (divides O (S a)) (λ (X-clearme : divides O (S a)) -> match-divides O (S a) lzero (λ (X-1 : divides O (S a)) -> False lzero) (λ (q : nat) -> λ (auto : eq lzero nat (S a) (times O q)) -> absurd lzero (eq lzero nat O (S a)) (rewrite-r lzero lzero nat n (λ (X--1 : nat) -> eq lzero nat X--1 (S a)) (rewrite-l lzero lzero nat (S a) (λ (X--1 : nat) -> eq lzero nat X--1 (S a)) (refl lzero nat (S a)) n (rewrite-l lzero lzero nat O (λ (X--1 : nat) -> eq lzero nat (S a) X--1) (rewrite-r lzero lzero nat (times q O) (λ (X--1 : nat) -> eq lzero nat (S a) X--1) (rewrite-l lzero lzero nat (times O q) (λ (X--1 : nat) -> eq lzero nat (S a) X--1) auto (times q O) (commutative-times O q)) O (times-n-O q)) n eqnO)) O eqnO) (not-eq-O-S a)) X-clearme))) n eqnO) (le-to-or-lt-eq O n (le-O-n n))

decidable-divides : (n : nat) -> (m : nat) -> decidable lzero (divides n m)
decidable-divides = λ (n : nat) -> λ (m : nat) -> match-Or lzero lzero (eq lzero bool (dividesb n m) true) (eq lzero bool (dividesb n m) false) lzero (λ (X-- : Or lzero lzero (eq lzero bool (dividesb n m) true) (eq lzero bool (dividesb n m) false)) -> decidable lzero (divides n m)) (λ (auto : eq lzero bool (dividesb n m) true) -> or-introl lzero lzero (divides n m) (Not lzero (divides n m)) (dividesb-true-to-divides n m (rewrite-r lzero lzero bool true (λ (X-- : bool) -> eq lzero bool X-- true) (refl lzero bool true) (dividesb n m) auto))) (λ (auto : eq lzero bool (dividesb n m) false) -> or-intror lzero lzero (divides n m) (Not lzero (divides n m)) (dividesb-false-to-not-divides n m (rewrite-r lzero lzero bool false (λ (X-- : bool) -> eq lzero bool X-- false) (refl lzero bool false) (dividesb n m) auto))) (true-or-false (dividesb n m))

divides-to-dividesb-true : (n : nat) -> (m : nat) -> (X-- : lt O n) -> (X--1 : divides n m) -> eq lzero bool (dividesb n m) true
divides-to-dividesb-true = λ (n : nat) -> λ (m : nat) -> λ (posn : lt O n) -> λ (divnm : divides n m) -> match-Or lzero lzero (eq lzero bool (dividesb n m) true) (eq lzero bool (dividesb n m) false) lzero (λ (X-- : Or lzero lzero (eq lzero bool (dividesb n m) true) (eq lzero bool (dividesb n m) false)) -> eq lzero bool (dividesb n m) true) (λ (auto : eq lzero bool (dividesb n m) true) -> rewrite-r lzero lzero bool true (λ (X-- : bool) -> eq lzero bool X-- true) (refl lzero bool true) (dividesb n m) auto) (λ (ndivbnm : eq lzero bool (dividesb n m) false) -> False-ind lzero lzero (λ (X-x-66 : False lzero) -> eq lzero bool (dividesb n m) true) (absurd lzero (divides n m) divnm (dividesb-false-to-not-divides n m (rewrite-r lzero lzero bool false (λ (X-- : bool) -> eq lzero bool X-- false) (refl lzero bool false) (dividesb n m) ndivbnm)))) (true-or-false (dividesb n m))

let-clause-15321 : (n : nat) -> (m : nat) -> (posn : lt O m) -> (eqn0 : eq lzero nat O n) -> (X-clearme : divides O m) -> (q : nat) -> (eqm : eq lzero nat m (times O q)) -> eq lzero nat m O
let-clause-15321 = λ (n : nat) -> λ (m : nat) -> λ (posn : lt O m) -> λ (eqn0 : eq lzero nat O n) -> λ (X-clearme : divides O m) -> λ (q : nat) -> λ (eqm : eq lzero nat m (times O q)) -> rewrite-r lzero lzero nat (times q O) (λ (X-- : nat) -> eq lzero nat m X--) (rewrite-l lzero lzero nat (times O q) (λ (X-- : nat) -> eq lzero nat m X--) eqm (times q O) (commutative-times O q)) O (times-n-O q)

let-clause-15591 : (n : nat) -> (m : nat) -> (posn : lt O m) -> (eqn0 : eq lzero nat O n) -> (X-clearme : divides O m) -> (q : nat) -> (eqm : eq lzero nat m (times O q)) -> eq lzero nat m n
let-clause-15591 = λ (n : nat) -> λ (m : nat) -> λ (posn : lt O m) -> λ (eqn0 : eq lzero nat O n) -> λ (X-clearme : divides O m) -> λ (q : nat) -> λ (eqm : eq lzero nat m (times O q)) -> rewrite-r lzero lzero nat O (λ (X-- : nat) -> eq lzero nat X-- n) eqn0 m (let-clause-15321 n m posn eqn0 X-clearme q eqm)

let-clause-15601 : (n : nat) -> (m : nat) -> (posn : lt O m) -> (eqn0 : eq lzero nat O n) -> (X-clearme : divides O m) -> (q : nat) -> (eqm : eq lzero nat m (times O q)) -> eq lzero nat n O
let-clause-15601 = λ (n : nat) -> λ (m : nat) -> λ (posn : lt O m) -> λ (eqn0 : eq lzero nat O n) -> λ (X-clearme : divides O m) -> λ (q : nat) -> λ (eqm : eq lzero nat m (times O q)) -> rewrite-l lzero lzero nat m (λ (X-- : nat) -> eq lzero nat X-- O) (let-clause-15321 n m posn eqn0 X-clearme q eqm) n (let-clause-15591 n m posn eqn0 X-clearme q eqm)

divides-to-dividesb-true1 : (n : nat) -> (m : nat) -> (X-- : lt O m) -> (X--1 : divides n m) -> eq lzero bool (dividesb n m) true
divides-to-dividesb-true1 = λ (n : nat) -> λ (m : nat) -> λ (posn : lt O m) -> match-Or lzero lzero (lt O n) (eq lzero nat O n) lzero (λ (X-- : Or lzero lzero (lt O n) (eq lzero nat O n)) -> (X--1 : divides n m) -> eq lzero bool (dividesb n m) true) (λ (auto : lt O n) -> λ (auto' : divides n m) -> divides-to-dividesb-true n m auto auto') (λ (eqn0 : eq lzero nat O n) -> eq-ind lzero lzero nat O (λ (x-1 : nat) -> λ (X-x-2 : eq lzero nat O x-1) -> (X-- : divides x-1 m) -> eq lzero bool (dividesb x-1 m) true) (λ (X-clearme : divides O m) -> match-divides O m lzero (λ (X-- : divides O m) -> eq lzero bool (dividesb O m) true) (λ (q : nat) -> λ (eqm : eq lzero nat m (times O q)) -> False-ind lzero lzero (λ (X-x-66 : False lzero) -> eq lzero bool (dividesb O m) true) (absurd lzero (le (S n) O) (eq-coerc lzero (le (S O) m) (le (S n) O) posn (rewrite-l lzero (lsuc lzero) nat n (λ (X-- : nat) -> eq (lsuc lzero) (Set (lzero)) (le (S X--) m) (le (S n) O)) (rewrite-r lzero (lsuc lzero) nat n (λ (X-- : nat) -> eq (lsuc lzero) (Set (lzero)) (le (S n) X--) (le (S n) O)) (rewrite-l lzero (lsuc lzero) nat n (λ (X-- : nat) -> eq (lsuc lzero) (Set (lzero)) (le (S n) n) (le (S n) X--)) (refl (lsuc lzero) (Set (lzero)) (le (S n) n)) O (let-clause-15601 n m posn eqn0 X-clearme q eqm)) m (let-clause-15591 n m posn eqn0 X-clearme q eqm)) O (let-clause-15601 n m posn eqn0 X-clearme q eqm))) (not-le-Sn-O n))) X-clearme) n eqn0) (le-to-or-lt-eq O n (le-O-n n))

not-divides-to-dividesb-false : (n : nat) -> (m : nat) -> (X-- : lt O n) -> (X--1 : Not lzero (divides n m)) -> eq lzero bool (dividesb n m) false
not-divides-to-dividesb-false = λ (n : nat) -> λ (m : nat) -> λ (posn : lt O n) -> match-Or lzero lzero (eq lzero bool (dividesb n m) true) (eq lzero bool (dividesb n m) false) lzero (λ (X-- : Or lzero lzero (eq lzero bool (dividesb n m) true) (eq lzero bool (dividesb n m) false)) -> (X--1 : Not lzero (divides n m)) -> eq lzero bool (dividesb n m) false) (λ (divbnm : eq lzero bool (dividesb n m) true) -> λ (ndivnm : Not lzero (divides n m)) -> False-ind lzero lzero (λ (X-x-66 : False lzero) -> eq lzero bool (dividesb n m) false) (absurd lzero (divides n m) (dividesb-true-to-divides n m (rewrite-r lzero lzero bool true (λ (X-- : bool) -> eq lzero bool X-- true) (refl lzero bool true) (dividesb n m) divbnm)) ndivnm)) (λ (auto : eq lzero bool (dividesb n m) false) -> λ (auto' : Not lzero (divides n m)) -> rewrite-r lzero lzero bool false (λ (X-- : bool) -> eq lzero bool X-- false) (refl lzero bool false) (dividesb n m) auto) (true-or-false (dividesb n m))

dividesb-div-true : (d : nat) -> (n : nat) -> (X-- : lt O n) -> (X--1 : eq lzero bool (dividesb d n) true) -> eq lzero bool (dividesb (div n d) n) true
dividesb-div-true = λ (d : nat) -> λ (n : nat) -> λ (posn : lt O n) -> λ (divbdn : eq lzero bool (dividesb d n) true) -> divides-to-dividesb-true1 (div n d) n posn (divides-div d n (dividesb-true-to-divides d n (rewrite-r lzero lzero bool true (λ (X-- : bool) -> eq lzero bool X-- true) (refl lzero bool true) (dividesb d n) divbdn)))

let-clause-1573 : (n : nat) -> (m : nat) -> (posn : lt O n) -> (X-clearme : divides m n) -> (d : nat) -> (auto : eq lzero nat O m) -> (auto' : eq lzero nat n (times m d)) -> eq lzero nat n m
let-clause-1573 = λ (n : nat) -> λ (m : nat) -> λ (posn : lt O n) -> λ (X-clearme : divides m n) -> λ (d : nat) -> λ (auto : eq lzero nat O m) -> λ (auto' : eq lzero nat n (times m d)) -> rewrite-r lzero lzero nat (times m d) (λ (X-- : nat) -> eq lzero nat n X--) auto' m (rewrite-l lzero lzero nat O (λ (X-- : nat) -> eq lzero nat m (times X-- d)) (rewrite-l lzero lzero nat O (λ (X-- : nat) -> eq lzero nat X-- (times O d)) (times-O-n d) m auto) m auto)

let-clause-1585 : (n : nat) -> (m : nat) -> (posn : lt O n) -> (X-clearme : divides m n) -> (d : nat) -> (auto : eq lzero nat O m) -> (auto' : eq lzero nat n (times m d)) -> eq lzero nat O n
let-clause-1585 = λ (n : nat) -> λ (m : nat) -> λ (posn : lt O n) -> λ (X-clearme : divides m n) -> λ (d : nat) -> λ (auto : eq lzero nat O m) -> λ (auto' : eq lzero nat n (times m d)) -> rewrite-r lzero lzero nat m (λ (X-- : nat) -> eq lzero nat O X--) auto n (let-clause-1573 n m posn X-clearme d auto auto')

dividesb-true-to-lt-O : (n : nat) -> (m : nat) -> (X-- : lt O n) -> (X--1 : divides m n) -> lt O m
dividesb-true-to-lt-O = λ (n : nat) -> λ (m : nat) -> λ (posn : lt O n) -> λ (X-clearme : divides m n) -> match-divides m n lzero (λ (X-- : divides m n) -> lt O m) (λ (d : nat) -> match-Or lzero lzero (lt O m) (eq lzero nat O m) lzero (λ (X-- : Or lzero lzero (lt O m) (eq lzero nat O m)) -> (X--1 : eq lzero nat n (times m d)) -> lt O m) (λ (auto : lt O m) -> λ (auto' : eq lzero nat n (times m d)) -> auto) (λ (auto : eq lzero nat O m) -> λ (auto' : eq lzero nat n (times m d)) -> eq-coerc lzero (lt O n) (lt O m) posn (rewrite-r lzero (lsuc lzero) nat n (λ (X-- : nat) -> eq (lsuc lzero) (Set (lzero)) (lt X-- n) (lt O m)) (rewrite-r lzero (lsuc lzero) nat n (λ (X-- : nat) -> eq (lsuc lzero) (Set (lzero)) (lt n n) (lt X-- m)) (rewrite-l lzero (lsuc lzero) nat n (λ (X-- : nat) -> eq (lsuc lzero) (Set (lzero)) (lt n n) (lt n X--)) (refl (lsuc lzero) (Set (lzero)) (lt n n)) m (let-clause-1573 n m posn X-clearme d auto auto')) O (let-clause-1585 n m posn X-clearme d auto auto')) O (let-clause-1585 n m posn X-clearme d auto auto'))) (le-to-or-lt-eq O m (le-O-n m))) X-clearme

prime : (X-- : nat) -> Set (lzero)
prime = λ (n : nat) -> And lzero lzero (lt (S O) n) ((m : nat) -> (X-- : divides m n) -> (X--1 : lt (S O) m) -> eq lzero nat m n)

not-prime-O : Not lzero (prime O)
not-prime-O = nmk lzero (prime O) (λ (X-clearme : prime O) -> match-And lzero lzero (lt (S O) O) ((m : nat) -> (X-- : divides m O) -> (X--1 : lt (S O) m) -> eq lzero nat m O) lzero (λ (X-- : And lzero lzero (lt (S O) O) ((m : nat) -> (X-- : divides m O) -> (X--1 : lt (S O) m) -> eq lzero nat m O)) -> False lzero) (λ (lt10 : lt (S O) O) -> λ (auto : (m : nat) -> (X-- : divides m O) -> (X--1 : lt (S O) m) -> eq lzero nat m O) -> absurd lzero (le (S (S O)) O) lt10 (not-le-Sn-O (S O))) X-clearme)

not-prime-SO : Not lzero (prime (S O))
not-prime-SO = nmk lzero (prime (S O)) (λ (X-clearme : prime (S O)) -> match-And lzero lzero (lt (S O) (S O)) ((m : nat) -> (X-- : divides m (S O)) -> (X--1 : lt (S O) m) -> eq lzero nat m (S O)) lzero (λ (X-- : And lzero lzero (lt (S O) (S O)) ((m : nat) -> (X-- : divides m (S O)) -> (X--1 : lt (S O) m) -> eq lzero nat m (S O))) -> False lzero) (λ (lt11 : lt (S O) (S O)) -> λ (auto : (m : nat) -> (X-- : divides m (S O)) -> (X--1 : lt (S O) m) -> eq lzero nat m (S O)) -> absurd lzero (le (S (S O)) (S O)) lt11 (not-le-Sn-n (S O))) X-clearme)

prime-to-lt-O : (p : nat) -> (X-- : prime p) -> lt O p
prime-to-lt-O = λ (p : nat) -> λ (X-clearme : prime p) -> match-And lzero lzero (lt (S O) p) ((m : nat) -> (X-- : divides m p) -> (X--1 : lt (S O) m) -> eq lzero nat m p) lzero (λ (X-- : And lzero lzero (lt (S O) p) ((m : nat) -> (X-- : divides m p) -> (X--1 : lt (S O) m) -> eq lzero nat m p)) -> lt O p) (λ (lt1p : lt (S O) p) -> λ (auto : (m : nat) -> (X-- : divides m p) -> (X--1 : lt (S O) m) -> eq lzero nat m p) -> lt-S-to-lt O p lt1p) X-clearme

prime-to-lt-SO : (p : nat) -> (X-- : prime p) -> lt (S O) p
prime-to-lt-SO = λ (p : nat) -> λ (X-clearme : prime p) -> match-And lzero lzero (lt (S O) p) ((m : nat) -> (X-- : divides m p) -> (X--1 : lt (S O) m) -> eq lzero nat m p) lzero (λ (X-- : And lzero lzero (lt (S O) p) ((m : nat) -> (X-- : divides m p) -> (X--1 : lt (S O) m) -> eq lzero nat m p)) -> lt (S O) p) (λ (lt1p : lt (S O) p) -> λ (auto : (m : nat) -> (X-- : divides m p) -> (X--1 : lt (S O) m) -> eq lzero nat m p) -> lt1p) X-clearme

smallest-factor : (X-- : nat) -> nat
smallest-factor = λ (n : nat) -> match-bool lzero (λ (X-- : bool) -> nat) n (min' n (S (S O)) (λ (m : nat) -> eqb (mod n m) O)) (leb n (S O))

smallest-factor-to-min : (n : nat) -> (X-- : lt (S O) n) -> eq lzero nat (smallest-factor n) (min' n (S (S O)) (λ (m : nat) -> eqb (mod n m) O))
smallest-factor-to-min = λ (n : nat) -> λ (lt1n : lt (S O) n) -> eq-ind-r lzero lzero bool false (λ (x : bool) -> λ (X-- : eq lzero bool x false) -> eq lzero nat (match-bool lzero (λ (X-0 : bool) -> nat) n (min' n (S (S O)) (λ (m : nat) -> eqb (match-nat lzero (λ (X-0 : nat) -> nat) n (λ (p : nat) -> mod-aux n n p) m) O)) x) (min' n (S (S O)) (λ (m : nat) -> eqb (match-nat lzero (λ (X-0 : nat) -> nat) n (λ (p : nat) -> mod-aux n n p) m) O))) (refl lzero nat (match-bool lzero (λ (X-- : bool) -> nat) n (min' n (S (S O)) (λ (m : nat) -> eqb (match-nat lzero (λ (X-- : nat) -> nat) n (λ (p : nat) -> mod-aux n n p) m) O)) false)) (leb n (S O)) (lt-to-leb-false n (S O) lt1n)

example1 : eq lzero nat (smallest-factor (S (S (S O)))) (S (S (S O)))
example1 = refl lzero nat (S (S (S O)))

example2 : eq lzero nat (smallest-factor (S (S (S (S O))))) (S (S O))
example2 = refl lzero nat (S (S O))

example3 : eq lzero nat (smallest-factor (S (S (S (S (S (S (S O)))))))) (S (S (S (S (S (S (S O)))))))
example3 = refl lzero nat (S (S (S (S (S (S (S O)))))))

le-SO-smallest-factor : (n : nat) -> (X-- : le n (S O)) -> eq lzero nat (smallest-factor n) n
le-SO-smallest-factor = λ (n : nat) -> λ (le1n : le n (S O)) -> eq-ind-r lzero lzero bool true (λ (x : bool) -> λ (X-- : eq lzero bool x true) -> eq lzero nat (match-bool lzero (λ (X-0 : bool) -> nat) n (min' n (S (S O)) (λ (m : nat) -> eqb (match-nat lzero (λ (X-0 : nat) -> nat) n (λ (p : nat) -> mod-aux n n p) m) O)) x) n) (refl lzero nat (match-bool lzero (λ (X-- : bool) -> nat) n (min' n (S (S O)) (λ (m : nat) -> eqb (match-nat lzero (λ (X-- : nat) -> nat) n (λ (p : nat) -> mod-aux n n p) m) O)) true)) (leb n (S O)) (le-to-leb-true n (S O) le1n)

lt-SO-smallest-factor : (n : nat) -> (X-- : lt (S O) n) -> lt (S O) (smallest-factor n)
lt-SO-smallest-factor = λ (n : nat) -> λ (lt1n : lt (S O) n) -> eq-ind-r lzero lzero nat (min' n (S (S O)) (λ (m : nat) -> eqb (mod n m) O)) (λ (x : nat) -> λ (X-- : eq lzero nat x (min' n (S (S O)) (λ (m : nat) -> eqb (mod n m) O))) -> lt (S O) x) (le-min-l (λ (m : nat) -> eqb (mod n m) O) n (S (S O))) (smallest-factor n) (smallest-factor-to-min n lt1n)

lt-O-smallest-factor : (n : nat) -> (X-- : lt O n) -> lt O (smallest-factor n)
lt-O-smallest-factor = λ (n : nat) -> λ (posn : lt O n) -> match-le (S O) lzero (λ (X-- : nat) -> λ (X-0 : le (S O) X--) -> lt O (smallest-factor X--)) (eq-ind-r lzero lzero nat (S O) (λ (x : nat) -> λ (X-- : eq lzero nat x (S O)) -> lt O x) (lt-O-S O) (smallest-factor (S O)) (le-SO-smallest-factor (S O) (lt-O-S O))) (λ (m : nat) -> λ (posm : le (S O) m) -> le-S-S-to-le (S O) (smallest-factor (S m)) (le-S (S (S O)) (smallest-factor (S m)) (lt-SO-smallest-factor (S m) (le-S-S (S O) m posm)))) n posn

divides-smallest-factor-n : (n : nat) -> (X-- : lt O n) -> divides (smallest-factor n) n
divides-smallest-factor-n = λ (n : nat) -> λ (posn : lt O n) -> match-Or lzero lzero (lt (S O) n) (eq lzero nat (S O) n) lzero (λ (X-- : Or lzero lzero (lt (S O) n) (eq lzero nat (S O) n)) -> divides (smallest-factor n) n) (λ (lt1n : lt (S O) n) -> mod-O-to-divides (smallest-factor n) n (lt-O-smallest-factor n posn) (eq-ind-r lzero lzero nat (min' n (S (S O)) (λ (m : nat) -> eqb (mod n m) O)) (λ (x : nat) -> λ (X-- : eq lzero nat x (min' n (S (S O)) (λ (m : nat) -> eqb (mod n m) O))) -> eq lzero nat (mod n x) O) (eqb-true-to-eq (mod n (min' n (S (S O)) (λ (m : nat) -> eqb (mod n m) O))) O (f-min-true (λ (X-- : nat) -> eqb (mod n X--) O) n (S (S O)) (ex-intro lzero lzero nat (λ (i : nat) -> And lzero lzero (And lzero lzero (le (S (S O)) i) (lt i (plus n (S (S O))))) (eq lzero bool (eqb (mod n i) O) true)) n (conj lzero lzero (And lzero lzero (le (S (S O)) n) (lt n (plus n (S (S O))))) (eq lzero bool (eqb (mod n n) O) true) (conj lzero lzero (le (S (S O)) n) (lt n (plus n (S (S O)))) lt1n (eq-coerc lzero (le (S n) (plus (S n) (S O))) (le (S n) (plus n (S (S O)))) (le-plus-n-r (S O) (S n)) (rewrite-l lzero (lsuc lzero) nat (plus (S O) (S n)) (λ (X-- : nat) -> eq (lsuc lzero) (Set (lzero)) (le (S n) X--) (le (S n) (plus n (S (S O))))) (rewrite-r lzero (lsuc lzero) nat (plus n (S (S O))) (λ (X-- : nat) -> eq (lsuc lzero) (Set (lzero)) (le (S n) X--) (le (S n) (plus n (S (S O))))) (refl (lsuc lzero) (Set (lzero)) (le (S n) (plus n (S (S O))))) (plus (S O) (S n)) (rewrite-l lzero lzero nat (S (plus (S O) n)) (λ (X-- : nat) -> eq lzero nat X-- (plus n (S (S O)))) (rewrite-l lzero lzero nat (plus n (S O)) (λ (X-- : nat) -> eq lzero nat (S X--) (plus n (S (S O)))) (plus-n-Sm n (S O)) (plus (S O) n) (commutative-plus n (S O))) (plus (S O) (S n)) (plus-n-Sm (S O) n))) (plus (S n) (S O)) (commutative-plus (S O) (S n))))) (divides-to-dividesb-true n n posn (divides-n-n n)))))) (smallest-factor n) (smallest-factor-to-min n lt1n))) (λ (H : eq lzero nat (S O) n) -> eq-ind lzero lzero nat (S O) (λ (x-1 : nat) -> λ (X-x-2 : eq lzero nat (S O) x-1) -> divides (smallest-factor x-1) x-1) (divides-n-n (smallest-factor (S O))) n H) (le-to-or-lt-eq (S O) n posn)

le-smallest-factor-n : (n : nat) -> le (smallest-factor n) n
le-smallest-factor-n = λ (n : nat) -> match-nat lzero (λ (X-- : nat) -> le (smallest-factor X--) X--) (le-n (smallest-factor O)) (λ (m : nat) -> divides-to-le (smallest-factor (S m)) (S m) (lt-O-S m) (divides-smallest-factor-n (S m) (lt-O-S m))) n

lt-smallest-factor-to-not-divides : (n : nat) -> (i : nat) -> (X-- : lt (S O) n) -> (X--1 : lt (S O) i) -> (X--2 : lt i (smallest-factor n)) -> Not lzero (divides i n)
lt-smallest-factor-to-not-divides = λ (n : nat) -> λ (i : nat) -> λ (ltn : lt (S O) n) -> λ (lti : lt (S O) i) -> eq-ind-r lzero lzero nat (min' n (S (S O)) (λ (m : nat) -> eqb (mod n m) O)) (λ (x : nat) -> λ (X-- : eq lzero nat x (min' n (S (S O)) (λ (m : nat) -> eqb (mod n m) O))) -> (X--1 : lt i x) -> Not lzero (divides i n)) (λ (ltmin : lt i (min' n (S (S O)) (λ (m : nat) -> eqb (mod n m) O))) -> not-to-not lzero (divides i n) (eq lzero nat (mod n i) O) (λ (divin : divides i n) -> divides-to-mod-O i n (lt-S-to-lt O i lti) divin) (eqb-false-to-not-eq (mod n i) O (lt-min-to-false (λ (m : nat) -> eqb (mod n m) O) n i (S (S O)) lti ltmin))) (smallest-factor n) (smallest-factor-to-min n ltn)

prime-smallest-factor-n : (n : nat) -> (X-- : lt (S O) n) -> prime (smallest-factor n)
prime-smallest-factor-n = λ (n : nat) -> λ (lt1n : lt (S O) n) -> conj lzero lzero (lt (S O) (smallest-factor n)) ((m : nat) -> (X-- : divides m (smallest-factor n)) -> (X--1 : lt (S O) m) -> eq lzero nat m (smallest-factor n)) (lt-SO-smallest-factor n lt1n) (λ (m : nat) -> λ (divmmin : divides m (smallest-factor n)) -> λ (lt1m : lt (S O) m) -> le-to-le-to-eq m (smallest-factor n) (divides-to-le m (smallest-factor n) (lt-O-smallest-factor n (lt-S-to-lt O n lt1n)) divmmin) (eq-ind-r lzero lzero nat (min' n (S (S O)) (λ (m0 : nat) -> eqb (mod n m0) O)) (λ (x : nat) -> λ (X-- : eq lzero nat x (min' n (S (S O)) (λ (m0 : nat) -> eqb (mod n m0) O))) -> le x m) (true-to-le-min (λ (m0 : nat) -> eqb (mod n m0) O) n m (S (S O)) lt1m (eq-to-eqb-true (mod n m) O (divides-to-mod-O m n (lt-S-to-lt O m lt1m) (transitive-divides m (smallest-factor n) n divmmin (divides-smallest-factor-n n (lt-S-to-lt O n lt1n)))))) (smallest-factor n) (smallest-factor-to-min n lt1n)))

prime-to-smallest-factor : (n : nat) -> (X-- : prime n) -> eq lzero nat (smallest-factor n) n
prime-to-smallest-factor = λ (n : nat) -> λ (X-clearme : prime n) -> match-And lzero lzero (lt (S O) n) ((m : nat) -> (X-- : divides m n) -> (X--1 : lt (S O) m) -> eq lzero nat m n) lzero (λ (X-- : And lzero lzero (lt (S O) n) ((m : nat) -> (X-- : divides m n) -> (X--1 : lt (S O) m) -> eq lzero nat m n)) -> eq lzero nat (smallest-factor n) n) (λ (lt1n : lt (S O) n) -> λ (primen : (m : nat) -> (X-- : divides m n) -> (X--1 : lt (S O) m) -> eq lzero nat m n) -> primen (smallest-factor n) (divides-smallest-factor-n n (lt-S-to-lt O n lt1n)) (lt-SO-smallest-factor n lt1n)) X-clearme

smallest-factor-to-prime : (n : nat) -> (X-- : lt (S O) n) -> (X--1 : eq lzero nat (smallest-factor n) n) -> prime n
smallest-factor-to-prime = λ (n : nat) -> λ (lt1n : lt (S O) n) -> λ (H : eq lzero nat (smallest-factor n) n) -> eq-ind lzero lzero nat (smallest-factor n) (λ (x-1 : nat) -> λ (X-x-2 : eq lzero nat (smallest-factor n) x-1) -> prime x-1) (prime-smallest-factor-n n lt1n) n H

primeb : (X-n : nat) -> bool
primeb = λ (n : nat) -> andb (leb (S (S O)) n) (eqb (smallest-factor n) n)

example4 : eq lzero bool (primeb (S (S (S O)))) true
example4 = refl lzero bool true

example5 : eq lzero bool (primeb (S (S (S (S (S (S O))))))) false
example5 = refl lzero bool false

example6 : eq lzero bool (primeb (S (S (S (S (S (S (S (S (S (S (S O)))))))))))) true
example6 = refl lzero bool true

example7 : eq lzero bool (primeb (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S O)))))))))))))))))) true
example7 = refl lzero bool true

primeb-true-to-prime : (n : nat) -> (X-- : eq lzero bool (primeb n) true) -> prime n
primeb-true-to-prime = λ (n : nat) -> λ (primebn : eq lzero bool (primeb n) true) -> smallest-factor-to-prime n (leb-true-to-le (S (S O)) n (andb-true-l (leb (S (S O)) n) (eqb (smallest-factor n) n) primebn)) (eqb-true-to-eq (smallest-factor n) n (andb-true-r (leb (S (S O)) n) (eqb (smallest-factor n) n) primebn))

primeb-false-to-not-prime : (n : nat) -> (X-- : eq lzero bool (primeb n) false) -> Not lzero (prime n)
primeb-false-to-not-prime = λ (n : nat) -> λ (H : eq lzero bool (primeb n) false) -> leb-elim lzero (S (S O)) n (λ (X-- : bool) -> (X--1 : eq lzero bool (andb X-- (eqb (smallest-factor n) n)) false) -> Not lzero (prime n)) (λ (X-- : le (S (S O)) n) -> λ (H1 : eq lzero bool (andb true (eqb (smallest-factor n) n)) false) -> not-to-not lzero (prime n) (eq lzero nat (smallest-factor n) n) (prime-to-smallest-factor n) (eqb-false-to-not-eq (smallest-factor n) n H1)) (λ (len1 : Not lzero (le (S (S O)) n)) -> λ (X-- : eq lzero bool (andb false (eqb (smallest-factor n) n)) false) -> not-to-not lzero (prime n) (le (S (S O)) n) (λ (X-clearme : prime n) -> match-And lzero lzero (lt (S O) n) ((m : nat) -> (X--1 : divides m n) -> (X--2 : lt (S O) m) -> eq lzero nat m n) lzero (λ (X-0 : And lzero lzero (lt (S O) n) ((m : nat) -> (X--1 : divides m n) -> (X--2 : lt (S O) m) -> eq lzero nat m n)) -> le (S (S O)) n) (λ (auto : lt (S O) n) -> λ (auto' : (m : nat) -> (X--1 : divides m n) -> (X--2 : lt (S O) m) -> eq lzero nat m n) -> auto) X-clearme) len1) H

decidable-prime : (n : nat) -> decidable lzero (prime n)
decidable-prime = λ (n : nat) -> match-Or lzero lzero (eq lzero bool (primeb n) true) (eq lzero bool (primeb n) false) lzero (λ (X-- : Or lzero lzero (eq lzero bool (primeb n) true) (eq lzero bool (primeb n) false)) -> decidable lzero (prime n)) (λ (H : eq lzero bool (primeb n) true) -> or-introl lzero lzero (prime n) (Not lzero (prime n)) (primeb-true-to-prime n (rewrite-r lzero lzero bool true (λ (X-- : bool) -> eq lzero bool X-- true) (refl lzero bool true) (primeb n) H))) (λ (H : eq lzero bool (primeb n) false) -> or-intror lzero lzero (prime n) (Not lzero (prime n)) (primeb-false-to-not-prime n (rewrite-r lzero lzero bool false (λ (X-- : bool) -> eq lzero bool X-- false) (refl lzero bool false) (primeb n) H))) (true-or-false (primeb n))

prime-to-primeb-true : (n : nat) -> (X-- : prime n) -> eq lzero bool (primeb n) true
prime-to-primeb-true = λ (n : nat) -> λ (primen : prime n) -> match-Or lzero lzero (eq lzero bool (primeb n) true) (eq lzero bool (primeb n) false) lzero (λ (X-- : Or lzero lzero (eq lzero bool (primeb n) true) (eq lzero bool (primeb n) false)) -> eq lzero bool (primeb n) true) (λ (auto : eq lzero bool (primeb n) true) -> rewrite-r lzero lzero bool true (λ (X-- : bool) -> eq lzero bool X-- true) (refl lzero bool true) (primeb n) auto) (λ (H : eq lzero bool (primeb n) false) -> False-ind lzero lzero (λ (X-x-66 : False lzero) -> eq lzero bool (primeb n) true) (absurd lzero (prime n) primen (primeb-false-to-not-prime n (rewrite-r lzero lzero bool false (λ (X-- : bool) -> eq lzero bool X-- false) (refl lzero bool false) (primeb n) H)))) (true-or-false (primeb n))

not-prime-to-primeb-false : (n : nat) -> (X-- : Not lzero (prime n)) -> eq lzero bool (primeb n) false
not-prime-to-primeb-false = λ (n : nat) -> λ (np : Not lzero (prime n)) -> match-Or lzero lzero (eq lzero bool (primeb n) true) (eq lzero bool (primeb n) false) lzero (λ (X-- : Or lzero lzero (eq lzero bool (primeb n) true) (eq lzero bool (primeb n) false)) -> eq lzero bool (primeb n) false) (λ (p : eq lzero bool (primeb n) true) -> False-ind lzero lzero (λ (X-x-66 : False lzero) -> eq lzero bool (primeb n) false) (absurd lzero (prime n) (primeb-true-to-prime n (rewrite-r lzero lzero bool true (λ (X-- : bool) -> eq lzero bool X-- true) (refl lzero bool true) (primeb n) p)) np)) (λ (auto : eq lzero bool (primeb n) false) -> rewrite-r lzero lzero bool false (λ (X-- : bool) -> eq lzero bool X-- false) (refl lzero bool false) (primeb n) auto) (true-or-false (primeb n))

divides-fact : (n : nat) -> (i : nat) -> (X-- : lt O i) -> (X--1 : le i n) -> divides i (fact n)
divides-fact = λ (n : nat) -> λ (i : nat) -> λ (ltOi : lt O i) -> nat-ind lzero (λ (X-x-365 : nat) -> (X-- : le i X-x-365) -> divides i (fact X-x-365)) (λ (leiO : le i O) -> False-ind lzero lzero (λ (X-x-66 : False lzero) -> divides i (fact O)) (absurd lzero (lt O i) ltOi (le-to-not-lt i O leiO))) (λ (n0 : nat) -> λ (Hind : (X-- : le i n0) -> divides i (fact n0)) -> λ (lei : le i (S n0)) -> match-Or lzero lzero (lt i (S n0)) (eq lzero nat i (S n0)) lzero (λ (X-- : Or lzero lzero (lt i (S n0)) (eq lzero nat i (S n0))) -> divides i (times (fact n0) (S n0))) (λ (ltiS : lt i (S n0)) -> transitive-divides i (fact n0) (times (fact n0) (S n0)) (Hind (eq-coerc lzero (le (pred (S i)) (pred (S n0))) (le i n0) (monotonic-pred (S i) (S n0) ltiS) (rewrite-l lzero (lsuc lzero) nat i (λ (X-- : nat) -> eq (lsuc lzero) (Set (lzero)) (le X-- (pred (S n0))) (le i n0)) (rewrite-l lzero (lsuc lzero) nat n0 (λ (X-- : nat) -> eq (lsuc lzero) (Set (lzero)) (le i X--) (le i n0)) (refl (lsuc lzero) (Set (lzero)) (le i n0)) (pred (S n0)) (pred-Sn n0)) (pred (S i)) (pred-Sn i)))) (quotient (fact n0) (times (fact n0) (S n0)) (S n0) (rewrite-l lzero lzero nat (plus (fact n0) (times (fact n0) n0)) (λ (X-- : nat) -> eq lzero nat X-- (times (fact n0) (S n0))) (rewrite-r lzero lzero nat (times n0 (fact n0)) (λ (X-- : nat) -> eq lzero nat (plus (fact n0) X--) (times (fact n0) (S n0))) (rewrite-r lzero lzero nat (times (S n0) (fact n0)) (λ (X-- : nat) -> eq lzero nat (plus (fact n0) (times n0 (fact n0))) X--) (rewrite-r lzero lzero nat (times (S n0) (fact n0)) (λ (X-- : nat) -> eq lzero nat X-- (times (S n0) (fact n0))) (refl lzero nat (times (S n0) (fact n0))) (plus (fact n0) (times n0 (fact n0))) (times-Sn-m n0 (fact n0))) (times (fact n0) (S n0)) (commutative-times (fact n0) (S n0))) (times (fact n0) n0) (commutative-times (fact n0) n0)) (times (fact n0) (S n0)) (times-n-Sm (fact n0) n0)))) (λ (eqi : eq lzero nat i (S n0)) -> eq-ind-r lzero lzero nat (S n0) (λ (x : nat) -> λ (X-- : eq lzero nat x (S n0)) -> divides x (times (fact n0) (S n0))) (eq-coerc lzero (divides (times i (S O)) (times i (fact n0))) (divides (S n0) (times (fact n0) (S n0))) (divides-times i (S O) i (fact n0) (divides-n-n i) (divides-SO-n (fact n0))) (rewrite-l lzero (lsuc lzero) nat i (λ (X-- : nat) -> eq (lsuc lzero) (Set (lzero)) (divides (times i (S O)) (times i (fact n0))) (divides X-- (times (fact n0) (S n0)))) (rewrite-l lzero (lsuc lzero) nat i (λ (X-- : nat) -> eq (lsuc lzero) (Set (lzero)) (divides (times i (S O)) (times i (fact n0))) (divides i (times (fact n0) X--))) (rewrite-r lzero (lsuc lzero) nat (times i (fact n0)) (λ (X-- : nat) -> eq (lsuc lzero) (Set (lzero)) (divides (times i (S O)) (times i (fact n0))) (divides i X--)) (rewrite-l lzero (lsuc lzero) nat i (λ (X-- : nat) -> eq (lsuc lzero) (Set (lzero)) (divides X-- (times i (fact n0))) (divides i (times i (fact n0)))) (refl (lsuc lzero) (Set (lzero)) (divides i (times i (fact n0)))) (times i (S O)) (times-n-1 i)) (times (fact n0) i) (commutative-times (fact n0) i)) (S n0) eqi) (S n0) eqi)) i eqi) (le-to-or-lt-eq i (S n0) lei)) n

mod-S-fact : (n : nat) -> (i : nat) -> (X-- : lt (S O) i) -> (X--1 : le i n) -> eq lzero nat (mod (S (fact n)) i) (S O)
mod-S-fact = λ (n : nat) -> λ (i : nat) -> λ (lt1i : lt (S O) i) -> λ (lein : le i n) -> eq-ind lzero lzero nat (mod (fact n) i) (λ (x-1 : nat) -> λ (X-x-2 : eq lzero nat (mod (fact n) i) x-1) -> eq lzero nat (mod (S (fact n)) i) (S x-1)) (mod-S (fact n) i (lt-S-to-lt O i lt1i) (eq-coerc lzero (lt (S O) i) (lt (S (mod (fact n) i)) i) lt1i (rewrite-r lzero (lsuc lzero) nat O (λ (X-- : nat) -> eq (lsuc lzero) (Set (lzero)) (lt (S O) i) (lt (S X--) i)) (refl (lsuc lzero) (Set (lzero)) (lt (S O) i)) (mod (fact n) i) (divides-to-mod-O i (fact n) (lt-S-to-lt O i lt1i) (divides-fact n i (lt-S-to-lt O i lt1i) lein))))) O (divides-to-mod-O i (fact n) (lt-S-to-lt O i lt1i) (divides-fact n i (lt-S-to-lt O i lt1i) lein))

not-divides-S-fact : (n : nat) -> (i : nat) -> (X-- : lt (S O) i) -> (X--1 : le i n) -> Not lzero (divides i (S (fact n)))
not-divides-S-fact = λ (n : nat) -> λ (i : nat) -> λ (lt1i : lt (S O) i) -> λ (lein : le i n) -> not-to-not lzero (divides i (S (fact n))) (eq lzero nat (mod (S (fact n)) i) O) (divides-to-mod-O i (S (fact n)) (lt-S-to-lt O i lt1i)) (eq-ind-r lzero lzero nat (S O) (λ (x : nat) -> λ (X-- : eq lzero nat x (S O)) -> Not lzero (eq lzero nat x O)) (eqb-false-to-not-eq (S O) O (refl lzero bool (eqb (S O) O))) (mod (S (fact n)) i) (mod-S-fact n i lt1i lein))

smallest-factor-fact : (n : nat) -> lt n (smallest-factor (S (fact n)))
smallest-factor-fact = λ (n : nat) -> not-le-to-lt (smallest-factor (S (fact n))) n (not-to-not lzero (le (smallest-factor (S (fact n))) n) (Not lzero (divides (smallest-factor (S (fact n))) (S (fact n)))) (not-divides-S-fact n (smallest-factor (S (fact n))) (lt-SO-smallest-factor (S (fact n)) (le-S-S (S O) (fact n) (le-1-fact n)))) (nmk lzero (Not lzero (divides (smallest-factor (S (fact n))) (S (fact n)))) (λ (X-clearme : Not lzero (divides (smallest-factor (S (fact n))) (S (fact n)))) -> match-Not lzero (divides (smallest-factor (S (fact n))) (S (fact n))) lzero (λ (X-- : Not lzero (divides (smallest-factor (S (fact n))) (S (fact n)))) -> False lzero) (λ (H : (X-- : divides (smallest-factor (S (fact n))) (S (fact n))) -> False lzero) -> H (divides-smallest-factor-n (S (fact n)) (le-S-S O (fact n) (le-O-n (fact n))))) X-clearme)))

ex-prime : (n : nat) -> (X-- : le (S O) n) -> ex lzero lzero nat (λ (m : nat) -> And lzero lzero (And lzero lzero (lt n m) (le m (S (fact n)))) (prime m))
ex-prime = λ (n : nat) -> λ (lein : le (S O) n) -> match-le (S O) lzero (λ (X-- : nat) -> λ (X-0 : le (S O) X--) -> ex lzero lzero nat (λ (m : nat) -> And lzero lzero (And lzero lzero (lt X-- m) (le m (S (fact X--)))) (prime m))) (ex-intro lzero lzero nat (λ (m : nat) -> And lzero lzero (And lzero lzero (lt (S O) m) (le m (S (fact (S O))))) (prime m)) (S (S O)) (conj lzero lzero (And lzero lzero (lt (S O) (S (S O))) (le (S (S O)) (S (fact (S O))))) (prime (S (S O))) (conj lzero lzero (lt (S O) (S (S O))) (le (S (S O)) (S (fact (S O)))) (smallest-factor-fact (S O)) (le-n (S (S O)))) (primeb-true-to-prime (S (S O)) (refl lzero bool (primeb (S (S O))))))) (λ (m : nat) -> λ (leim : le (S O) m) -> ex-intro lzero lzero nat (λ (m0 : nat) -> And lzero lzero (And lzero lzero (lt (S m) m0) (le m0 (S (fact (S m))))) (prime m0)) (smallest-factor (S (fact (S m)))) (conj lzero lzero (And lzero lzero (lt (S m) (smallest-factor (S (fact (S m))))) (le (smallest-factor (S (fact (S m)))) (S (fact (S m))))) (prime (smallest-factor (S (fact (S m))))) (conj lzero lzero (lt (S m) (smallest-factor (S (fact (S m))))) (le (smallest-factor (S (fact (S m)))) (S (fact (S m)))) (smallest-factor-fact (S m)) (le-smallest-factor-n (S (fact (S m))))) (prime-smallest-factor-n (S (fact (S m))) (le-S-S (S O) (fact (S m)) (le-1-fact (S m)))))) n lein

nth-prime : (X---v : nat) -> nat
let-previous-prime : (X---v : nat) -> (p-v : nat) -> nat
let-upper-bound : (X---v : nat) -> (p-v : nat) -> nat

let-upper-bound = λ (X---v : nat) -> λ (p-v : nat) -> S (fact (let-previous-prime X---v p-v))
let-previous-prime = λ (X---v : nat) -> λ (p-v : nat) -> nth-prime p-v
nth-prime O = (S (S O))
nth-prime (S p) =  min' (let-upper-bound (S p) p) (S (let-previous-prime (S p) p)) primeb


let-previous-prime1 : (n : nat) -> nat
let-previous-prime1 = λ (n : nat) -> nth-prime n

let-upper-bound1 : (n : nat) -> nat
let-upper-bound1 = λ (n : nat) -> S (fact (let-previous-prime1 n))

nth-primeS : (n : nat) -> eq lzero nat (nth-prime (S n)) (min' (let-upper-bound1 n) (S (let-previous-prime1 n)) primeb)
nth-primeS = λ (n : nat) -> refl lzero nat (nth-prime (S n))

example11 : eq lzero nat (nth-prime (S (S O))) (S (S (S (S (S O)))))
example11 = refl lzero nat (S (S (S (S (S O)))))

example12 : eq lzero nat (nth-prime (S (S (S O)))) (S (S (S (S (S (S (S O)))))))
example12 = refl lzero nat (S (S (S (S (S (S (S O)))))))

example13 : eq lzero nat (nth-prime (S (S (S (S O))))) (S (S (S (S (S (S (S (S (S (S (S O)))))))))))
example13 = refl lzero nat (S (S (S (S (S (S (S (S (S (S (S O)))))))))))

let-previous-prime2 : (n : nat) -> (m : nat) -> nat
let-previous-prime2 = λ (n : nat) -> λ (m : nat) -> nth-prime m

let-upper-bound2 : (n : nat) -> (m : nat) -> nat
let-upper-bound2 = λ (n : nat) -> λ (m : nat) -> S (fact (let-previous-prime2 n m))

let-previous-prime3 : (n : nat) -> (m : nat) -> (x : nat) -> nat
let-previous-prime3 = λ (n : nat) -> λ (m : nat) -> λ (x : nat) -> nth-prime m

let-upper-bound3 : (n : nat) -> (m : nat) -> (x : nat) -> nat
let-upper-bound3 = λ (n : nat) -> λ (m : nat) -> λ (x : nat) -> S (fact (let-previous-prime3 n m x))

let-previous-prime4 : (n : nat) -> (m : nat) -> nat
let-previous-prime4 = λ (n : nat) -> λ (m : nat) -> nth-prime m

let-upper-bound4 : (n : nat) -> (m : nat) -> nat
let-upper-bound4 = λ (n : nat) -> λ (m : nat) -> S (fact (let-previous-prime4 n m))

prime-nth-prime : (n : nat) -> prime (nth-prime n)
prime-nth-prime = λ (n : nat) -> match-nat lzero (λ (X-- : nat) -> prime (nth-prime X--)) (primeb-true-to-prime (nth-prime O) (refl lzero bool (primeb (nth-prime O)))) (λ (m : nat) -> eq-ind-r lzero lzero nat (min' (let-upper-bound2 n m) (S (let-previous-prime2 n m)) primeb) (λ (x : nat) -> λ (X-- : eq lzero nat x (min' (let-upper-bound3 n m x) (S (let-previous-prime3 n m x)) primeb)) -> prime x) (primeb-true-to-prime (min' (let-upper-bound4 n m) (S (let-previous-prime4 n m)) primeb) (f-min-true primeb (S (fact (nth-prime m))) (S (nth-prime m)) (ex-intro lzero lzero nat (λ (i : nat) -> And lzero lzero (And lzero lzero (le (S (nth-prime m)) i) (lt i (plus (S (fact (nth-prime m))) (S (nth-prime m))))) (eq lzero bool (primeb i) true)) (smallest-factor (S (fact (nth-prime m)))) (conj lzero lzero (And lzero lzero (le (S (nth-prime m)) (smallest-factor (S (fact (nth-prime m))))) (lt (smallest-factor (S (fact (nth-prime m)))) (plus (S (fact (nth-prime m))) (S (nth-prime m))))) (eq lzero bool (primeb (smallest-factor (S (fact (nth-prime m))))) true) (conj lzero lzero (le (S (nth-prime m)) (smallest-factor (S (fact (nth-prime m))))) (lt (smallest-factor (S (fact (nth-prime m)))) (plus (S (fact (nth-prime m))) (S (nth-prime m)))) (smallest-factor-fact (nth-prime m)) (le-S-S (smallest-factor (S (fact (nth-prime m)))) (plus (fact (nth-prime m)) (S (nth-prime m))) (transitive-le (smallest-factor (S (fact (nth-prime m)))) (S (fact (nth-prime m))) (plus (fact (nth-prime m)) (S (nth-prime m))) (le-smallest-factor-n (S (fact (nth-prime m)))) (eq-ind lzero lzero nat (S (plus (fact (nth-prime m)) (nth-prime m))) (λ (x-1 : nat) -> λ (X-x-2 : eq lzero nat (S (plus (fact (nth-prime m)) (nth-prime m))) x-1) -> le (S (fact (nth-prime m))) x-1) (le-plus-n-r (nth-prime m) (S (fact (nth-prime m)))) (plus (fact (nth-prime m)) (S (nth-prime m))) (plus-n-Sm (fact (nth-prime m)) (nth-prime m)))))) (prime-to-primeb-true (smallest-factor (S (fact (nth-prime m)))) (prime-smallest-factor-n (S (fact (nth-prime m))) (le-S-S (S O) (fact (nth-prime m)) (le-1-fact (nth-prime m))))))))) (nth-prime (S m)) (nth-primeS m)) n

increasing-nth-prime : (n : nat) -> lt (nth-prime n) (nth-prime (S n))
increasing-nth-prime = λ (n : nat) -> le-min-l primeb (S (fact (nth-prime n))) (S (nth-prime n))

lt-SO-nth-prime-n : (n : nat) -> lt (S O) (nth-prime n)
lt-SO-nth-prime-n = λ (n : nat) -> prime-to-lt-SO (nth-prime n) (prime-nth-prime n)

lt-O-nth-prime-n : (n : nat) -> lt O (nth-prime n)
lt-O-nth-prime-n = λ (n : nat) -> prime-to-lt-O (nth-prime n) (prime-nth-prime n)

lt-n-nth-prime-n : (n : nat) -> lt n (nth-prime n)
lt-n-nth-prime-n = λ (n : nat) -> nat-ind lzero (λ (X-x-365 : nat) -> lt X-x-365 (nth-prime X-x-365)) (lt-O-nth-prime-n O) (λ (m : nat) -> λ (ltm : lt m (nth-prime m)) -> le-to-lt-to-lt (S m) (nth-prime m) (nth-prime (S m)) ltm (increasing-nth-prime m)) n

let-previous-prime5 : (n : nat) -> (m : nat) -> (ltml : lt (nth-prime n) m) -> nat
let-previous-prime5 = λ (n : nat) -> λ (m : nat) -> λ (ltml : lt (nth-prime n) m) -> nth-prime n

let-upper-bound5 : (n : nat) -> (m : nat) -> (ltml : lt (nth-prime n) m) -> nat
let-upper-bound5 = λ (n : nat) -> λ (m : nat) -> λ (ltml : lt (nth-prime n) m) -> S (fact (let-previous-prime5 n m ltml))

let-previous-prime6 : (n : nat) -> (m : nat) -> (ltml : lt (nth-prime n) m) -> (x : nat) -> nat
let-previous-prime6 = λ (n : nat) -> λ (m : nat) -> λ (ltml : lt (nth-prime n) m) -> λ (x : nat) -> nth-prime n

let-upper-bound6 : (n : nat) -> (m : nat) -> (ltml : lt (nth-prime n) m) -> (x : nat) -> nat
let-upper-bound6 = λ (n : nat) -> λ (m : nat) -> λ (ltml : lt (nth-prime n) m) -> λ (x : nat) -> S (fact (let-previous-prime6 n m ltml x))

let-previous-prime7 : (n : nat) -> (m : nat) -> (ltml : lt (nth-prime n) m) -> nat
let-previous-prime7 = λ (n : nat) -> λ (m : nat) -> λ (ltml : lt (nth-prime n) m) -> nth-prime n

let-upper-bound7 : (n : nat) -> (m : nat) -> (ltml : lt (nth-prime n) m) -> nat
let-upper-bound7 = λ (n : nat) -> λ (m : nat) -> λ (ltml : lt (nth-prime n) m) -> S (fact (let-previous-prime7 n m ltml))

lt-nth-prime-to-not-prime : (n : nat) -> (m : nat) -> (X-- : lt (nth-prime n) m) -> (X--1 : lt m (nth-prime (S n))) -> Not lzero (prime m)
lt-nth-prime-to-not-prime = λ (n : nat) -> λ (m : nat) -> λ (ltml : lt (nth-prime n) m) -> eq-ind-r lzero lzero nat (min' (let-upper-bound5 n m ltml) (S (let-previous-prime5 n m ltml)) primeb) (λ (x : nat) -> λ (X-- : eq lzero nat x (min' (let-upper-bound6 n m ltml x) (S (let-previous-prime6 n m ltml x)) primeb)) -> (X--1 : lt m x) -> Not lzero (prime m)) (λ (ltmr : lt m (min' (let-upper-bound7 n m ltml) (S (let-previous-prime7 n m ltml)) primeb)) -> primeb-false-to-not-prime m (lt-min-to-false primeb (S (fact (nth-prime n))) m (S (nth-prime n)) ltml ltmr)) (nth-prime (S n)) (nth-primeS n)

prime-to-nth-prime : (p : nat) -> (X-- : prime p) -> ex lzero lzero nat (λ (i : nat) -> eq lzero nat (nth-prime i) p)
prime-to-nth-prime = λ (p : nat) -> λ (primep : prime p) -> match-ex lzero lzero nat (λ (i : nat) -> And lzero lzero (le (nth-prime i) p) (lt p (nth-prime (S i)))) lzero (λ (X-- : ex lzero lzero nat (λ (m : nat) -> And lzero lzero (le (nth-prime m) p) (lt p (nth-prime (S m))))) -> ex lzero lzero nat (λ (i : nat) -> eq lzero nat (nth-prime i) p)) (λ (n : nat) -> λ (X-clearme : And lzero lzero (le (nth-prime n) p) (lt p (nth-prime (S n)))) -> match-And lzero lzero (le (nth-prime n) p) (lt p (nth-prime (S n))) lzero (λ (X-- : And lzero lzero (le (nth-prime n) p) (lt p (nth-prime (S n)))) -> ex lzero lzero nat (λ (i : nat) -> eq lzero nat (nth-prime i) p)) (λ (lepl : le (nth-prime n) p) -> λ (ltpr : lt p (nth-prime (S n))) -> match-Or lzero lzero (lt (nth-prime n) p) (eq lzero nat (nth-prime n) p) lzero (λ (X-- : Or lzero lzero (lt (nth-prime n) p) (eq lzero nat (nth-prime n) p)) -> ex lzero lzero nat (λ (i : nat) -> eq lzero nat (nth-prime i) p)) (λ (ltpl : lt (nth-prime n) p) -> False-ind lzero lzero (λ (X-x-66 : False lzero) -> ex lzero lzero nat (λ (i : nat) -> eq lzero nat (nth-prime i) p)) (absurd lzero (prime p) primep (lt-nth-prime-to-not-prime n p ltpl ltpr))) (λ (eqp : eq lzero nat (nth-prime n) p) -> ex-intro lzero lzero nat (λ (i : nat) -> eq lzero nat (nth-prime i) p) n (rewrite-r lzero lzero nat p (λ (X-- : nat) -> eq lzero nat X-- p) (refl lzero nat p) (nth-prime n) eqp)) (le-to-or-lt-eq (nth-prime n) p lepl)) X-clearme) (increasing-to-le2 nth-prime (λ (n : nat) -> increasing-nth-prime n) p (prime-to-lt-SO p primep))

